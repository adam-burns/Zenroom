The files in this directory are "pure" LUA extensions statically
compiled as binaries and loaded inside zenroom as strings. This is
because the Zenroom cannot access the filesystem.

The extensions are compiled into C headers by the Makefile target
`embed-lua` which needs to be run manually in case of addition of new
extensions. Then zmake embed-luaz will create `lualib_*.c` files inside
the src/ directory. To complete inclusion they should be added at the
beginning of the lua_functions.c files (inside the #include directive
as if they'd be headers) and at the end of the file by the
lsb_load_string() taking them as string arguments.

-- Concise Binary Object Representation (CBOR)
-- RFC 7049

-- local function softreq(pkg, field)
-- 	-- local ok, mod = pcall(require, pkg);
-- 	-- if not ok then return end
-- 	if field then return [field]; end
-- 	return mod;
-- end
-- local dostring = function (s)
-- 	local ok, f = pcall(loadstring or load, s); -- luacheck: read globals loadstring
-- 	if ok and f then return f(); end
-- end

local setmetatable = setmetatable;
local getmetatable = getmetatable;
local dbg_getmetatable = debug.getmetatable;
local assert = assert;
local error = error;
local type = type;
local pairs = pairs;
local ipairs = ipairs;
local tostring = tostring;
local s_char = string.char;
local t_concat = table.concat;
local t_sort = table.sort;
local m_floor = math.floor;
local m_abs = math.abs;
local m_huge = math.huge;
local m_max = math.max;
local maxint = math.maxinteger or 9007199254740992;
local minint = math.mininteger or -9007199254740992;
local NaN = 0/0;
local m_frexp = math.frexp;
local m_ldexp = math.ldexp or function (x, exp) return x * 2.0 ^ exp; end;
local m_type = math.type or function (n) return n % 1 == 0 and n <= maxint and n >= minint and "integer" or "float" end;
local s_pack = string.pack -- or softreq("struct", "pack");
local s_unpack = string.unpack -- or softreq("struct", "unpack");
local b_rshift = bit32.rshift -- softreq("bit32", "rshift") or softreq("bit", "rshift") or
	-- dostring "return function(a,b) return a >> b end" or
	-- function (a, b) return m_max(0, m_floor(a / (2 ^ b))); end;

-- sanity check
if s_pack and s_pack(">I2", 0) ~= "\0\0" then
	s_pack = nil;
end
if s_unpack and s_unpack(">I2", "\1\2\3\4") ~= 0x102 then
	s_unpack = nil;
end

local encoder = {};

local function encode(obj, opts)
	return encoder[type(obj)](obj, opts);
end

-- Major types 0, 1 and length encoding for others
local function integer(num, m)
	if m == 0 and num < 0 then
		-- negative integer, major type 1
		num, m = - num - 1, 32;
	end
	if num < 24 then
		return s_char(m + num);
	elseif num < 2 ^ 8 then
		return s_char(m + 24, num);
	elseif num < 2 ^ 16 then
		return s_char(m + 25, b_rshift(num, 8), num % 0x100);
	elseif num < 2 ^ 32 then
		return s_char(m + 26,
			b_rshift(num, 24) % 0x100,
			b_rshift(num, 16) % 0x100,
			b_rshift(num, 8) % 0x100,
			num % 0x100);
	elseif num < 2 ^ 64 then
		local high = m_floor(num / 2 ^ 32);
		num = num % 2 ^ 32;
		return s_char(m + 27,
			b_rshift(high, 24) % 0x100,
			b_rshift(high, 16) % 0x100,
			b_rshift(high, 8) % 0x100,
			high % 0x100,
			b_rshift(num, 24) % 0x100,
			b_rshift(num, 16) % 0x100,
			b_rshift(num, 8) % 0x100,
			num % 0x100);
	end
	error "int too large";
end

if s_pack then
	function integer(num, m)
		local fmt;
		m = m or 0;
		if num < 24 then
			fmt, m = ">B", m + num;
		elseif num < 256 then
			fmt, m = ">BB", m + 24;
		elseif num < 65536 then
			fmt, m = ">BI2", m + 25;
		elseif num < 4294967296 then
			fmt, m = ">BI4", m + 26;
		else
			fmt, m = ">BI8", m + 27;
		end
		return s_pack(fmt, m, num);
	end
end

local simple_mt = {};
function simple_mt:__tostring() return self.name or ("simple(%d)"):format(self.value); end
function simple_mt:__tocbor() return self.cbor or integer(self.value, 224); end

local function simple(value, name, cbor)
	assert(value >= 0 and value <= 255, "bad argument #1 to 'simple' (integer in range 0..255 expected)");
	return setmetatable({ value = value, name = name, cbor = cbor }, simple_mt);
end

local tagged_mt = {};
function tagged_mt:__tostring() return ("%d(%s)"):format(self.tag, tostring(self.value)); end
function tagged_mt:__tocbor() return integer(self.tag, 192) .. encode(self.value); end

local function tagged(tag, value)
	assert(tag >= 0, "bad argument #1 to 'tagged' (positive integer expected)");
	return setmetatable({ tag = tag, value = value }, tagged_mt);
end

local null = simple(22, "null"); -- explicit null
local undefined = simple(23, "undefined"); -- undefined or nil
local BREAK = simple(31, "break", "\255");

-- Number types dispatch
function encoder.number(num)
	return encoder[m_type(num)](num);
end

-- Major types 0, 1
function encoder.integer(num)
	if num < 0 then
		return integer(-1 - num, 32);
	end
	return integer(num, 0);
end

-- Major type 7
function encoder.float(num)
	if num ~= num then -- NaN shortcut
		return "\251\127\255\255\255\255\255\255\255";
	end
	local sign = (num > 0 or 1 / num > 0) and 0 or 1;
	num = m_abs(num)
	if num == m_huge then
		return s_char(251, sign * 128 + 128 - 1) .. "\240\0\0\0\0\0\0";
	end
	local fraction, exponent = m_frexp(num)
	if fraction == 0 then
		return s_char(251, sign * 128) .. "\0\0\0\0\0\0\0";
	end
	fraction = fraction * 2;
	exponent = exponent + 1024 - 2;
	if exponent <= 0 then
		fraction = fraction * 2 ^ (exponent - 1)
		exponent = 0;
	else
		fraction = fraction - 1;
	end
	return s_char(251,
		sign * 2 ^ 7 + m_floor(exponent / 2 ^ 4) % 2 ^ 7,
		exponent % 2 ^ 4 * 2 ^ 4 +
		m_floor(fraction * 2 ^ 4 % 0x100),
		m_floor(fraction * 2 ^ 12 % 0x100),
		m_floor(fraction * 2 ^ 20 % 0x100),
		m_floor(fraction * 2 ^ 28 % 0x100),
		m_floor(fraction * 2 ^ 36 % 0x100),
		m_floor(fraction * 2 ^ 44 % 0x100),
		m_floor(fraction * 2 ^ 52 % 0x100)
	)
end

if s_pack then
	function encoder.float(num)
		return s_pack(">Bd", 251, num);
	end
end


-- Major type 2 - byte strings
function encoder.bytestring(s)
	return integer(#s, 64) .. s;
end

-- Major type 3 - UTF-8 strings
function encoder.utf8string(s)
	return integer(#s, 96) .. s;
end

-- Lua strings are byte strings
encoder.string = encoder.bytestring;

function encoder.boolean(bool)
	return bool and "\245" or "\244";
end

encoder["nil"] = function() return "\246"; end

function encoder.userdata(ud, opts)
	local mt = dbg_getmetatable(ud);
	if mt then
		local encode_ud = opts and opts[mt] or mt.__tocbor;
		if encode_ud then
			return encode_ud(ud, opts);
		end
	end
	error "can't encode userdata";
end

function encoder.table(t, opts)
	local mt = getmetatable(t);
	if mt then
		local encode_t = opts and opts[mt] or mt.__tocbor;
		if encode_t then
			return encode_t(t, opts);
		end
	end
	-- the table is encoded as an array iff when we iterate over it,
	-- we see successive integer keys starting from 1.  The lua
	-- language doesn't actually guarantee that this will be the case
	-- when we iterate over a table with successive integer keys, but
	-- due an implementation detail in PUC Rio Lua, this is what we
	-- usually observe.  See the Lua manual regarding the # (length)
	-- operator.  In the case that this does not happen, we will fall
	-- back to a map with integer keys, which becomes a bit larger.
	local array, map, i, p = { integer(#t, 128) }, { "\191" }, 1, 2;
	local is_array = true;
	for k, v in pairs(t) do
		is_array = is_array and i == k;
		i = i + 1;

		local encoded_v = encode(v, opts);
		array[i] = encoded_v;

		map[p], p = encode(k, opts), p + 1;
		map[p], p = encoded_v, p + 1;
	end
	-- map[p] = "\255";
	map[1] = integer(i - 1, 160);
	return t_concat(is_array and array or map);
end

-- Array or dict-only encoders, which can be set as __tocbor metamethod
function encoder.array(t, opts)
	local array = { };
	for i, v in ipairs(t) do
		array[i] = encode(v, opts);
	end
	return integer(#array, 128) .. t_concat(array);
end

function encoder.map(t, opts)
	local map, p, len = { "\191" }, 2, 0;
	for k, v in pairs(t) do
		map[p], p = encode(k, opts), p + 1;
		map[p], p = encode(v, opts), p + 1;
		len = len + 1;
	end
	-- map[p] = "\255";
	map[1] = integer(len, 160);
	return t_concat(map);
end
encoder.dict = encoder.map; -- COMPAT

function encoder.ordered_map(t, opts)
	local map = {};
	if not t[1] then -- no predefined order
		local i = 0;
		for k in pairs(t) do
			i = i + 1;
			map[i] = k;
		end
		t_sort(map);
	end
	for i, k in ipairs(t[1] and t or map) do
		map[i] = encode(k, opts) .. encode(t[k], opts);
	end
	return integer(#map, 160) .. t_concat(map);
end

-- stringify the function hex address
encoder['function'] = function(f)
   local val = strtok(tostring(f))[2]
   return integer(#val, 64) .. val
end

-- Decoder
-- Reads from a file-handle like object
local function read_bytes(fh, len)
	return fh:read(len);
end

local function read_byte(fh)
	return fh:read(1):byte();
end

local function read_length(fh, mintyp)
	if mintyp < 24 then
		return mintyp;
	elseif mintyp < 28 then
		local out = 0;
		for _ = 1, 2 ^ (mintyp - 24) do
			out = out * 256 + read_byte(fh);
		end
		return out;
	else
		error "invalid length";
	end
end

local decoder = {};

local function read_type(fh)
	local byte = read_byte(fh);
	return b_rshift(byte, 5), byte % 32;
end

local function read_object(fh, opts)
	local typ, mintyp = read_type(fh);
	return decoder[typ](fh, mintyp, opts);
end

local function read_integer(fh, mintyp)
	return read_length(fh, mintyp);
end

local function read_negative_integer(fh, mintyp)
	return -1 - read_length(fh, mintyp);
end

local function read_string(fh, mintyp)
	if mintyp ~= 31 then
		return read_bytes(fh, read_length(fh, mintyp));
	end
	local out = {};
	local i = 1;
	local v = read_object(fh);
	while v ~= BREAK do
		out[i], i = v, i + 1;
		v = read_object(fh);
	end
	return t_concat(out);
end

local function read_unicode_string(fh, mintyp)
	return read_string(fh, mintyp);
	-- local str = read_string(fh, mintyp);
	-- if have_utf8 and not utf8.len(str) then
		-- TODO How to handle this?
	-- end
	-- return str;
end

local function read_array(fh, mintyp, opts)
	local out = {};
	if mintyp == 31 then
		local i = 1;
		local v = read_object(fh, opts);
		while v ~= BREAK do
			out[i], i = v, i + 1;
			v = read_object(fh, opts);
		end
	else
		local len = read_length(fh, mintyp);
		for i = 1, len do
			out[i] = read_object(fh, opts);
		end
	end
	return out;
end

local function read_map(fh, mintyp, opts)
	local out = {};
	local k;
	if mintyp == 31 then
		local i = 1;
		k = read_object(fh, opts);
		while k ~= BREAK do
			out[k], i = read_object(fh, opts), i + 1;
			k = read_object(fh, opts);
		end
	else
		local len = read_length(fh, mintyp);
		for _ = 1, len do
			k = read_object(fh, opts);
			out[k] = read_object(fh, opts);
		end
	end
	return out;
end

local tagged_decoders = {};

local function read_semantic(fh, mintyp, opts)
	local tag = read_length(fh, mintyp);
	local value = read_object(fh, opts);
	local postproc = opts and opts[tag] or tagged_decoders[tag];
	if postproc then
		return postproc(value);
	end
	return tagged(tag, value);
end

local function read_half_float(fh)
	local exponent = read_byte(fh);
	local fraction = read_byte(fh);
	local sign = exponent < 128 and 1 or -1; -- sign is highest bit

	fraction = fraction + (exponent * 256) % 1024; -- copy two(?) bits from exponent to fraction
	exponent = b_rshift(exponent, 2) % 32; -- remove sign bit and two low bits from fraction;

	if exponent == 0 then
		return sign * m_ldexp(fraction, -24);
	elseif exponent ~= 31 then
		return sign * m_ldexp(fraction + 1024, exponent - 25);
	elseif fraction == 0 then
		return sign * m_huge;
	else
		return NaN;
	end
end

local function read_float(fh)
	local exponent = read_byte(fh);
	local fraction = read_byte(fh);
	local sign = exponent < 128 and 1 or -1; -- sign is highest bit
	exponent = exponent * 2 % 256 + b_rshift(fraction, 7);
	fraction = fraction % 128;
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);

	if exponent == 0 then
		return sign * m_ldexp(exponent, -149);
	elseif exponent ~= 0xff then
		return sign * m_ldexp(fraction + 2 ^ 23, exponent - 150);
	elseif fraction == 0 then
		return sign * m_huge;
	else
		return NaN;
	end
end

local function read_double(fh)
	local exponent = read_byte(fh);
	local fraction = read_byte(fh);
	local sign = exponent < 128 and 1 or -1; -- sign is highest bit

	exponent = exponent %  128 * 16 + b_rshift(fraction, 4);
	fraction = fraction % 16;
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);
	fraction = fraction * 256 + read_byte(fh);

	if exponent == 0 then
		return sign * m_ldexp(exponent, -149);
	elseif exponent ~= 0xff then
		return sign * m_ldexp(fraction + 2 ^ 52, exponent - 1075);
	elseif fraction == 0 then
		return sign * m_huge;
	else
		return NaN;
	end
end


if s_unpack then
	function read_float(fh) return s_unpack(">f", read_bytes(fh, 4)) end
	function read_double(fh) return s_unpack(">d", read_bytes(fh, 8)) end
end

local function read_simple(fh, value, opts)
	if value == 24 then
		value = read_byte(fh);
	end
	if value == 20 then
		return false;
	elseif value == 21 then
		return true;
	elseif value == 22 then
		return null;
	elseif value == 23 then
		return undefined;
	elseif value == 25 then
		return read_half_float(fh);
	elseif value == 26 then
		return read_float(fh);
	elseif value == 27 then
		return read_double(fh);
	elseif value == 31 then
		return BREAK;
	end
	if opts and opts.simple then
		return opts.simple(value);
	end
	return simple(value);
end

decoder[0] = read_integer;
decoder[1] = read_negative_integer;
decoder[2] = read_string;
decoder[3] = read_unicode_string;
decoder[4] = read_array;
decoder[5] = read_map;
decoder[6] = read_semantic;
decoder[7] = read_simple;

-- opts.more(n) -> want more data
-- opts.simple -> decode simple value
-- opts[int] -> tagged decoder
local function decode(s, opts)
	local fh = {};
	local pos = 1;

	local more;
	if type(opts) == "function" then
		more = opts;
	elseif type(opts) == "table" then
		more = opts.more;
	elseif opts ~= nil then
		error(("bad argument #2 to 'decode' (function or table expected, got %s)"):format(type(opts)));
	end
	if type(more) ~= "function" then
		function more()
			error "input too short";
		end
	end

	function fh:read(bytes)
		local ret = s:sub(pos, pos + bytes - 1);
		if #ret < bytes then
			ret = more(bytes - #ret, fh, opts);
			if ret then self:write(ret); end
			return self:read(bytes);
		end
		pos = pos + bytes;
		return ret;
	end

	function fh:write(bytes) -- luacheck: no self
		s = s .. bytes;
		if pos > 256 then
			s = s:sub(pos + 1);
			pos = 1;
		end
		return #bytes;
	end

	return read_object(fh, opts);
end

return {
	-- en-/decoder functions
    raw_encode = encode;
	raw_decode = decode;

	-- tables of per-type en-/decoders
	type_encoders = encoder;
	type_decoders = decoder;

	-- special treatment for tagged values
	tagged_decoders = tagged_decoders;

	-- constructors for annotated types
	simple = simple;
	tagged = tagged;

	-- pre-defined simple values
	null = null;
	undefined = undefined;
};
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2020 Dyne.org foundation
-- Coconut implementation by Alberto Sonnino and Denis Roio
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.


-- Coconut is a selective disclosure credential scheme for Attribute
-- Based Credentials (ABC) supporting public and private attributes,
-- re-randomization, and multiple unlinkable selective attribute
-- revelations. For information about usage see
-- https://zenroom.dyne.org and https://decodeproject.eu
ECP     = require_once('zenroom_ecp')
ECP2    = require_once('zenroom_ecp2')

local coco = {
   _VERSION = 'crypto_coconut.lua 1.1',
   _URL = 'https://zenroom.dyne.org',
   _DESCRIPTION = 'Attribute-based credential system supporting multiple unlinkable private attribute revelations',
   _LICENSE = [[
Licensed under the terms of the GNU Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.  Unless required by applicable
law or agreed to in writing, software distributed under the License
is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied.
]]
}

local G1 = ECP.generator() -- return value
local G2 = ECP2.generator() -- return value
local O  = ECP.order() -- return value

-- stateful challenge hardcoded string
local hs = ECP.hashtopoint(str([[
Developed for the DECODE project
]] .. coco._LICENSE))
local challenge = G1:octet() .. G2:octet() .. hs:octet()
function coco.to_challenge(list)
   -- assert(coco.challenge, "COCONUT secret challenge not set")
   return INT.new( sha256( challenge .. OCTET.serialize(list)))
end

-- local zero-knowledge proof verifications
local function make_pi_s(gamma, commit, k, r, m)
   local wk = INT.random()
   local wm = INT.random()
   local wr = INT.random()
   local Aw = G1 * wk
   local Bw = gamma * wk + commit * wm
   local Cw = G1 * wr + hs * wm
   local c = coco.to_challenge({ commit, Aw, Bw, Cw })
   local rk = wk - c * k
   local rm = wm - c * m
   local rr = wr - c * r
   -- return Lambda
   return { c  = c,
			rk = rk,
			rm = rm,
			rr = rr }
end

function coco.verify_pi_s(l)
   local Aw = l.c.a * l.pi_s.c
	  + G1 * l.pi_s.rk
   local Bw = l.c.b * l.pi_s.c
	  + l.public * l.pi_s.rk
	  + l.commit * l.pi_s.rm
   local Cw = l.commit * l.pi_s.c
	  + G1 * l.pi_s.rr
	  + hs * l.pi_s.rm
   -- return a bool for assert
   return l.pi_s.c == coco.to_challenge({ l.commit, Aw, Bw, Cw })
end

-- Public Coconut API
function coco.ca_keygen()
   local x = INT.random()
   local y = INT.random()
   local sk = { x = x,
                y = y  }
   local vk = { alpha = G2 * x,
                beta  = G2 * y  }
   -- return keypair
   return sk, vk
end

function coco.aggregate_keys(keys)
   local agg_alpha = keys[1].alpha
   local agg_beta  = keys[1].beta
   if #keys > 1 then
	  for i = 2, #keys do
		 agg_alpha = agg_alpha + keys[i].alpha
		 agg_beta  = agg_beta  + keys[i].beta
	  end
   end
   -- return aggkeys
   return { alpha = agg_alpha,
			beta = agg_beta }
end

function coco.prepare_blind_sign(gamma, secret)
   local m = INT.new(sha256(secret))
   -- ElGamal commitment
   local r = INT.random()
   local commit = G1 * r + hs * m
   local k = INT.random()
   local c = { a = G1 * k,
			   b = gamma * k + commit * m }
   -- calculate zero knowledge proofs
   local pi_s = make_pi_s(gamma, commit, k, r, m)
   -- return Lambda
   return { commit = commit,
            c    = c,
            pi_s = pi_s,
			public = gamma }
end

function coco.blind_sign(sk, Lambda)
   ZEN.assert(coco.verify_pi_s(Lambda),
			  'Zero knowledge proof does not verify (Lambda.pi_s)')
   local h = Lambda.commit
   local a_tilde = Lambda.c.a * sk.y
   local b_tilde = h * sk.x + Lambda.c.b * sk.y
   -- sigma tilde
   return { h = h,
            a_tilde = a_tilde,
            b_tilde = b_tilde  }
end

function coco.aggregate_creds(sk, sigma_tilde)
   local agg_s =
	  -- ElGamal verify commitment
	  sigma_tilde[1].b_tilde - sigma_tilde[1].a_tilde * sk

   if #sigma_tilde > 1 then
      for i = 2, #sigma_tilde do
         agg_s = agg_s +
			sigma_tilde[i].b_tilde - sigma_tilde[i].a_tilde * sk
      end
   end
   -- aggregated sigma
   return { h = sigma_tilde[1].h,
            s = agg_s }
end

function coco.prove_creds(vk, sigma, secret)
   ZEN.assert(vk, "COCONUT.prove_creds called with empty verifier")
   ZEN.assert(sigma, "COCONUT.prove_creds called with empty credential")
   ZEN.assert(secret, "COCONUT.prove_creds called with empty secret")

   local m = INT.new(sha256(secret))
   local r = INT.random()
   local r_prime = INT.random()
   local sigma_prime = { h_prime = sigma.h * r_prime,
                         s_prime = sigma.s * r_prime  }
   local kappa = vk.alpha + vk.beta * m + G2 * r
   local nu = sigma_prime.h_prime * r
   -- make pi_v
   local wm = INT.random()
   local wr = INT.random()
   local Aw = vk.alpha + G2 * wr + vk.beta * wm
   local Bw = sigma_prime.h_prime * wr
   local ch = coco.to_challenge({ vk.alpha, vk.beta, Aw, Bw })
   local pi_v = { c = ch,
				  rm = wm - m * ch,
				  rr = wr - r * ch }
   -- return Theta
   local Theta = {
      kappa = kappa, -- ECP2
      nu = nu,       -- ECP
      sigma_prime = sigma_prime, -- ECP tuple
      pi_v = pi_v } -- INTs
   return Theta
end

function coco.verify_creds(vk, Theta)
   ZEN.assert(vk, "COCONUT.verify_creds called with empty verifier")
   ZEN.assert(Theta, "COCONUT.verify_creds valled with empty proof")
   if #vk == 1 then vk = vk[1] end -- single element in array
   -- verify pi_v
   local Aw = Theta.kappa * Theta.pi_v.c
	  + G2 * Theta.pi_v.rr
	  + vk.alpha * (INT.new(1) - Theta.pi_v.c)
	  + vk.beta * Theta.pi_v.rm
   local Bw = Theta.nu * Theta.pi_v.c
	  + Theta.sigma_prime.h_prime * Theta.pi_v.rr
   -- check zero knowledge proof
   ZEN.assert(Theta.pi_v.c == coco.to_challenge({vk.alpha, vk.beta, Aw, Bw}),
			  "Credential proof does not verify (wrong challenge)")
   ZEN.assert(not Theta.sigma_prime.h_prime:isinf(),
			  "Credential proof does not verify (sigma.h is infinite)")
   ZEN.assert(ECP2.miller(Theta.kappa, Theta.sigma_prime.h_prime)
				 == ECP2.miller(G2, Theta.sigma_prime.s_prime + Theta.nu),
			  "Credential proof does not verify (miller loop error)")
   return true
end

-----------
-- petition

function coco.prove_cred_petition(vk, sigma, secret, uid)
   local m = INT.new(sha256(secret))
   local r = INT.random()
   -- local m = INT.new(sha256(secret))
   -- material
   local r_prime = INT.random()
   local sigma_prime = { h_prime = sigma.h * r_prime,
						 s_prime = sigma.s * r_prime  }
   local kappa = vk.alpha
	  + vk.beta * m
	  + G2 * r
   local nu = sigma_prime.h_prime * r
   local zeta = m * ECP.hashtopoint(uid)
   -- proof --
   -- create the witnessess
   local wm = INT.random()
   local wr = INT.random()
   -- compute the witnessess commitments
   local Aw = G2 * wr
	  + vk.alpha
	  + vk.beta * wm
   local Bw = sigma_prime.h_prime * wr
   local Cw = wm * ECP.hashtopoint(uid)
   -- create the challenge
   local c = COCONUT.to_challenge({ vk.alpha, vk.beta, Aw, Bw, Cw })
   -- create responses
   local rm = wm - m * c
   local rr = wr - r * c
   local pi_v = { c = c,
				  rm = rm,
				  rr = rr }
   local Theta = {
      kappa = kappa,
      nu = nu,
      sigma_prime = sigma_prime,
      pi_v = pi_v }
   return Theta, zeta
end

function coco.verify_cred_petition(vk, Theta, zeta, uid)
   local kappa = Theta.kappa
   local nu = Theta.nu
   local sigma_prime = Theta.sigma_prime
   local c = Theta.pi_v.c
   local rm = Theta.pi_v.rm
   local rr = Theta.pi_v.rr
   -- verify proof --
   -- recompute witnessess commitments
   local Aw = kappa * c
	  + G2 * rr
	  + vk.alpha * (INT.new(1) - c)
	  + vk.beta * rm
   local Bw = nu * c + sigma_prime.h_prime * rr
   local Cw = rm*ECP.hashtopoint(uid) + zeta*c
   -- compute the challenge prime
   ZEN.assert(c == COCONUT.to_challenge({ vk.alpha, vk.beta, Aw, Bw, Cw }),
			  "verify_cred_petition: invalid challenge")
   -- verify signature --
   ZEN.assert(not sigma_prime.h_prime:isinf(),
			  "verify_cred_petition: sigma_prime.h points at infinite")
   ZEN.assert(ECP2.miller(kappa, sigma_prime.h_prime)
				 == ECP2.miller(G2, sigma_prime.s_prime + nu),
			  "verify_cred_petition: miller loop fails")
   return true
end

-- takes an array of bigs and a curve order (modulo)
function coco.lagrange_interpolation(indexes)
   ZEN.assert(type(indexes) == "table", "Lagrange interpolation argument is not an array")
   local l = {}
   local numerator
   local denominator
   for i in indexes do
	  numerator = BIG.new(1)
	  denominator = BIG.new(1)
	  for j in indexes do
		 if (j ~= i)
		 then
            numerator = numerator * (x - j)
            denominator = denominator * (i - j)
		 end
		 l[#l+1] = numerator * denominator:modinv(O)
	  end
   end
   return l
end

function coco.prove_sign_petition(pub, m)
   -- sign == vote
   local k = INT.random()
   -- vote encryption
   local enc_v = { left = G1 * k,
				   right = pub * k + hs * m }
   -- opposite of vote encryption
   local enc_v_neg = { left = enc_v.left:negative(),
					   right = enc_v.right:negative() + hs }
   -- commitment to the vote
   local r1 = INT.random()
   local r2 = r1 * (BIG.new(1) - m)
   local cv = G1 * m + hs * r1

   -- proof
   -- create the witnesess
   local wk = INT.random()
   local wm = INT.random()
   local wr1 = INT.random()
   local wr2 = INT.random()
   -- compute the witnessess commitments
   local Aw = G1*wk
   local Bw = pub*wk + hs*wm
   local Cw = G1*wm + hs*wr1
   local Dw = cv*wm + hs*wr2
   -- create the challenge
   local c = COCONUT.to_challenge({enc_v.left, enc_v.right,
								   cv, Aw, Bw, Cw, Dw}) % O
   -- create responses
   local rk = wk - c * k
   local rm = wm - c * m
   local rr1 = wr1 - c * r1
   local rr2 = wr2 - c * r2
   local pi_vote = { c = c,
					 rk = rk,
					 rm = rm,
					 rr1 = rr1,
					 rr2 = rr2 }

   -- signature's Theta
   return { scores = { pos = enc_v,
					   neg = enc_v_neg }, -- left/right tuples
			cv = cv, -- ecp
			pi_vote = pi_vote } -- pi
end

function coco.verify_sign_petition(pub, theta)
   -- recompute witnessess commitment
   local scores = theta.scores.pos -- only positive, not negative?
   local Aw = G1 * theta.pi_vote.rk
	  + scores.left * theta.pi_vote.c
   local Bw = pub * theta.pi_vote.rk
	  + hs * theta.pi_vote.rm
	  + scores.right * theta.pi_vote.c
   local Cw = G1 * theta.pi_vote.rm
	  + hs * theta.pi_vote.rr1
	  + theta.cv * theta.pi_vote.c
   local Dw = theta.cv * theta.pi_vote.rm
	  + hs * theta.pi_vote.rr2
	  + theta.cv * theta.pi_vote.c
   -- verify challenge
   ZEN.assert(theta.pi_vote.c == COCONUT.to_challenge(
				 {scores.left, scores.right,
				  theta.cv, Aw, Bw, Cw, Dw }),
			  "verify_sign_petition: challenge fails")
   return true
end

function coco.prove_tally_petition(sk, scores)
   local wx = INT.random()
   local Aw = { wx:modneg(O) * scores.pos.left,
				wx:modneg(O) * scores.neg.left  }
   local c = COCONUT.to_challenge(Aw)
   local rx = wx - c * sk
   local dec = { pos = scores.pos.left * sk:modneg(O),
				 neg = scores.neg.left * sk:modneg(O) }
   -- return pi_tally
   return { dec = dec,
			rx = rx,
			c = c    }
end

function coco.verify_tally_petition(scores, pi_tally)
   local rxneg = pi_tally.rx:modneg(O)
   local Aw = { rxneg*scores.pos.left + pi_tally.c * pi_tally.dec.pos,
				rxneg*scores.neg.left + pi_tally.c * pi_tally.dec.neg  }
   ZEN.assert(pi_tally.c == COCONUT.to_challenge(Aw),
			  "verify_tally_petition: challenge fails")
   return true
end

function coco.count_signatures_petition(scores, pi_tally)
   local restab = { }
   for idx=1,1000 do
	  -- if idx ~= 0 then -- not zero
	  restab[(BIG.new(idx) * hs):octet():hex()] = idx
	  -- end
   end
   local res = { pos = scores.pos.right + pi_tally.dec.pos,
				 neg = scores.neg.right + pi_tally.dec.neg  }
   return { pos = restab[res.pos:octet():hex()],
			neg = restab[res.neg:octet():hex()]  }
end
return coco
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2020 Dyne.org foundation
-- Written by Denis Roio <jaromil@dyne.org>
--
-- Elgamal based Additive Homomorphic commitment scheme 
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- This scheme is not efficiently decryptable, since decrypting needs
-- to solve the discrete log problem. If numbers are from a small
-- range, this is useful. Otherwise using Paillier is more convenient.

local elgah = {
   _VERSION = 'crypto_elgamal.lua 0.5',
   _URL = 'https://zenroom.dyne.org',
   _DESCRIPTION = 'Elgamal based Additive Homomorphic commitment scheme ',
   _LICENSE = [[
Licensed under the terms of the GNU Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.  Unless required by applicable
law or agreed to in writing, software distributed under the License
is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
CONDITIONS OF ANY KIND, either express or implied.
]]
}

local G = ECP.generator() -- return value
local O  = ECP.order() -- return value


-- stateful challenge hardcoded string
local hs = ECP.hashtopoint(str([[
Jaromil started writing this code on Tuesday 21st January 2020
]] .. elgah._LICENSE))
local challenge = G:octet() .. hs:octet()
local function to_challenge(list)
   return INT.new( sha256( challenge .. OCTET.serialize(list)))
end

function elgah.keygen()
	  local res = { private = INT.random() }
	  res.public = G * res.private
	  return(res)
end

function elgah.new(pub, m)
   -- sign == vote
   local k = INT.random()
   local hsm = hs * m -- optimisation
   -- vote encryption
   local enc_v = { left = G * k,
				   right = pub * k + hsm }
   -- opposite of vote encryption
   local enc_v_neg = { left = enc_v.left:negative(),
					   right = enc_v.right:negative() + hs }

   -- commitment to the vote
   local r = INT.random()
   local cv = G * r + hsm

   -- proof
   -- create the witnesess
   local wk = INT.random()
   local wm = INT.random()
   local wr = INT.random()

   local hswm = hs * wm -- optimisation
   -- compute the witnessess commitments
   local Aw = G  * wk
   local Bw = pub * wk + hswm
   local Cw = G  * wr + hswm

   -- create the challenge
   local c = to_challenge({enc_v.left, enc_v.right,
						   cv, Aw, Bw, Cw})
   -- create responses
   local rk = wk - c * k
   local rm = wm - c * m
   local rr = wr - c * r
   local pi = { c = c,
				rk = rk,
				rm = rm,
				rr = rr }

   -- signature's Theta
   return { value = { pos = enc_v,
					  neg = enc_v_neg }, -- left/right tuples
			cv = cv, -- ecp
			pi = pi } -- pi
end

function elgah.verify(pub, theta)
   -- recompute witnessess commitment
   ZEN.assert(theta.pi,   "ELGAH.verify 1st argument has no proof")
   ZEN.assert(theta.value,"ELGAH.verify 2nd argument has no value")

   local value = theta.value.pos
   local Aw = G * theta.pi.rk
	  + value.left * theta.pi.c
   local Bw = pub * theta.pi.rk
	  + hs * theta.pi.rm
	  + value.right * theta.pi.c
   local Cw = G * theta.pi.rr
	  + hs * theta.pi.rm
	  + theta.cv * theta.pi.c
   -- verify challenge
   ZEN.assert(theta.pi.c == to_challenge(
				 {value.left, value.right,
				  theta.cv, Aw, Bw, Cw }),
			  "ELGAH.verify: challenge fails")
   return true
end

function elgah.zero()
   return { pos = { left = ECP.infinity(), right = ECP.infinity() },
			neg = { left = ECP.infinity(), right = ECP.infinity() } }
end

function elgah.add(pub, a, b)
   elgah.verify(pub, a)
   local pos = { left = nil, right = nil }
   local neg = { left = nil, right = nil }
   pos.left  = a.value.pos.left  + b.pos.left
   pos.right = a.value.pos.right + b.pos.right
   neg.left  = a.value.neg.left  + b.neg.left
   neg.right = a.value.neg.right + b.neg.right
   return { pos = pos, neg = neg }
end

function elgah.sub(pub, a, b)
   elgah.verify(pub, a)
   local pos = { left = nil, right = nil }
   local neg = { left = nil, right = nil }
   pos.left  = a.value.pos.left  - b.pos.left
   pos.right = a.value.pos.right - b.pos.right
   neg.left  = a.value.neg.left  - b.neg.left
   neg.right = a.value.neg.right - b.neg.right
   return { pos = pos, neg = neg }
end

function elgah.tally(pub, priv, n)
   local wx = INT.random()
   local Aw = { wx:modneg(O) * n.pos.left,
				wx:modneg(O) * n.neg.left  }
   local c = to_challenge(Aw)
   local rx = wx - c * priv
   local dec = { pos = n.pos.left * priv:modneg(O),
				 neg = n.neg.left * priv:modneg(O) }
   -- return pi_tally
   return { dec = dec,
			rx  = rx,
			c   = c   }
end

function elgah.verify_tally(tally, value)
   local rxneg = tally.rx:modneg(O)
   local Aw = { rxneg * value.pos.left + tally.c * tally.dec.pos,
				rxneg * value.neg.left + tally.c * tally.dec.neg  }
   ZEN.assert(tally.c == to_challenge(Aw),
		  "ELGAH.verify_tally: challenge fails")
   return true
end

function elgah.count(tally, value, max)
   elgah.verify_tally(tally, value)
   local restab = { }
   max = max or 1000
   for idx=1,max do
	  restab[(BIG.new(idx) * hs):octet():url64()] = idx
   end
   local res = { pos = value.pos.right + tally.dec.pos,
				 neg = value.neg.right + tally.dec.neg  }
   return restab[res.pos:octet():url64()]
end

return elgah
---------------------------------------------------------------------------------------
-- Module for date and time calculations
--
-- Version 2.1.1
-- Copyright (C) 2006, by Jas Latrix (jastejada@yahoo.com)
-- Copyright (C) 2013-2014, by Thijs Schreijer
-- Licensed under MIT, http://opensource.org/licenses/MIT

--[[ CONSTANTS ]]--
  local HOURPERDAY  = 24
  local MINPERHOUR  = 60
  local MINPERDAY    = 1440  -- 24*60
  local SECPERMIN   = 60
  local SECPERHOUR  = 3600  -- 60*60
  local SECPERDAY   = 86400 -- 24*60*60
  local TICKSPERSEC = 1000000
  local TICKSPERDAY = 86400000000
  local TICKSPERHOUR = 3600000000
  local TICKSPERMIN = 60000000
  local DAYNUM_MAX =  365242500 -- Sat Jan 01 1000000 00:00:00
  local DAYNUM_MIN = -365242500 -- Mon Jan 01 1000000 BCE 00:00:00
  local DAYNUM_DEF =  0 -- Mon Jan 01 0001 00:00:00
  local _;
--[[ LOCAL ARE FASTER ]]--
  local type     = type
  local pairs    = pairs
  local error    = error
  local assert   = assert
  local tonumber = tonumber
  local tostring = tostring
  local string   = string
  local math     = math
  local os       = { }
  local unpack   = unpack or table.unpack
  local setmetatable = setmetatable
  local getmetatable = getmetatable
--[[ EXTRA FUNCTIONS ]]--
  local fmt  = string.format
  local lwr  = string.lower
  local rep  = string.rep
  local len  = string.len  -- luacheck: ignore
  local sub  = string.sub
  local gsub = string.gsub
  local gmatch = string.gmatch or string.gfind
  local find = string.find
  local floor = math.floor
  local ceil  = math.ceil
  local abs   = math.abs
  local osdate = function() return nil end
  local ostime = function() return nil end

  -- removes the decimal part of a number
  local function fix(n) n = tonumber(n) return n and ((n > 0 and floor or ceil)(n)) end
  -- returns the modulo n % d;
  local function mod(n,d) return n - d*floor(n/d) end
  -- is `str` in string list `tbl`, `ml` is the minimun len
  local function inlist(str, tbl, ml, tn)
    local sl = len(str)
    if sl < (ml or 0) then return nil end
    str = lwr(str)
    for k, v in pairs(tbl) do
      if str == lwr(sub(v, 1, sl)) then
        if tn then tn[0] = k end
        return k
      end
    end
  end
  local function fnil() end
--[[ DATE FUNCTIONS ]]--
  local DATE_EPOCH -- to be set later
  local sl_weekdays = {
    [0]="Sunday",[1]="Monday",[2]="Tuesday",[3]="Wednesday",[4]="Thursday",[5]="Friday",[6]="Saturday",
    [7]="Sun",[8]="Mon",[9]="Tue",[10]="Wed",[11]="Thu",[12]="Fri",[13]="Sat",
  }
  local sl_meridian = {[-1]="AM", [1]="PM"}
  local sl_months = {
    [00]="January", [01]="February", [02]="March",
    [03]="April",   [04]="May",      [05]="June",
    [06]="July",    [07]="August",   [08]="September",
    [09]="October", [10]="November", [11]="December",
    [12]="Jan", [13]="Feb", [14]="Mar",
    [15]="Apr", [16]="May", [17]="Jun",
    [18]="Jul", [19]="Aug", [20]="Sep",
    [21]="Oct", [22]="Nov", [23]="Dec",
  }
  -- added the '.2'  to avoid collision, use `fix` to remove
  local sl_timezone = {
    [000]="utc",    [0.2]="gmt",
    [300]="est",    [240]="edt",
    [360]="cst",  [300.2]="cdt",
    [420]="mst",  [360.2]="mdt",
    [480]="pst",  [420.2]="pdt",
  }
  -- set the day fraction resolution
  local function setticks(t)
    TICKSPERSEC = t;
    TICKSPERDAY = SECPERDAY*TICKSPERSEC
    TICKSPERHOUR= SECPERHOUR*TICKSPERSEC
    TICKSPERMIN = SECPERMIN*TICKSPERSEC
  end
  -- is year y leap year?
  local function isleapyear(y) -- y must be int!
    return (mod(y, 4) == 0 and (mod(y, 100) ~= 0 or mod(y, 400) == 0))
  end
  -- day since year 0
  local function dayfromyear(y) -- y must be int!
    return 365*y + floor(y/4) - floor(y/100) + floor(y/400)
  end
  -- day number from date, month is zero base
  local function makedaynum(y, m, d)
    local mm = mod(mod(m,12) + 10, 12)
    return dayfromyear(y + floor(m/12) - floor(mm/10)) + floor((mm*306 + 5)/10) + d - 307
    --local yy = y + floor(m/12) - floor(mm/10)
    --return dayfromyear(yy) + floor((mm*306 + 5)/10) + (d - 1)
  end
  -- date from day number, month is zero base
  local function breakdaynum(g)
    local g = g + 306
    local y = floor((10000*g + 14780)/3652425)
    local d = g - dayfromyear(y)
    if d < 0 then y = y - 1; d = g - dayfromyear(y) end
    local mi = floor((100*d + 52)/3060)
    return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
  end
  --[[ for floats or int32 Lua Number data type
  local function breakdaynum2(g)
    local g, n = g + 306;
    local n400 = floor(g/DI400Y);n = mod(g,DI400Y);
    local n100 = floor(n/DI100Y);n = mod(n,DI100Y);
    local n004 = floor(n/DI4Y);   n = mod(n,DI4Y);
    local n001 = floor(n/365);   n = mod(n,365);
    local y = (n400*400) + (n100*100) + (n004*4) + n001  - ((n001 == 4 or n100 == 4) and 1 or 0)
    local d = g - dayfromyear(y)
    local mi = floor((100*d + 52)/3060)
    return (floor((mi + 2)/12) + y), mod(mi + 2,12), (d - floor((mi*306 + 5)/10) + 1)
  end
  ]]
  -- day fraction from time
  local function makedayfrc(h,r,s,t)
    return ((h*60 + r)*60 + s)*TICKSPERSEC + t
  end
  -- time from day fraction
  local function breakdayfrc(df)
    return
      mod(floor(df/TICKSPERHOUR),HOURPERDAY),
      mod(floor(df/TICKSPERMIN ),MINPERHOUR),
      mod(floor(df/TICKSPERSEC ),SECPERMIN),
      mod(df,TICKSPERSEC)
  end
  -- weekday sunday = 0, monday = 1 ...
  local function weekday(dn) return mod(dn + 1, 7) end
  -- yearday 0 based ...
  local function yearday(dn)
     return dn - dayfromyear((breakdaynum(dn))-1)
  end
  -- parse v as a month
  local function getmontharg(v)
    local m = tonumber(v);
    return (m and fix(m - 1)) or inlist(tostring(v) or "", sl_months, 2)
  end
  -- get daynum of isoweek one of year y
  local function isow1(y)
    local f = makedaynum(y, 0, 4) -- get the date for the 4-Jan of year `y`
    local d = weekday(f)
    d = d == 0 and 7 or d -- get the ISO day number, 1 == Monday, 7 == Sunday
    return f + (1 - d)
  end
  local function isowy(dn)
    local w1;
    local y = (breakdaynum(dn))
    if dn >= makedaynum(y, 11, 29) then
      w1 = isow1(y + 1);
      if dn < w1 then
        w1 = isow1(y);
      else
          y = y + 1;
      end
    else
      w1 = isow1(y);
      if dn < w1 then
        w1 = isow1(y-1)
        y = y - 1
      end
    end
    return floor((dn-w1)/7)+1, y
  end
  local function isoy(dn)
    local y = (breakdaynum(dn))
    return y + (((dn >= makedaynum(y, 11, 29)) and (dn >= isow1(y + 1))) and 1 or (dn < isow1(y) and -1 or 0))
  end
  local function makedaynum_isoywd(y,w,d)
    return isow1(y) + 7*w + d - 8 -- simplified: isow1(y) + ((w-1)*7) + (d-1)
  end
--[[ THE DATE MODULE ]]--
  local fmtstr  = "%x %X";
--#if not DATE_OBJECT_AFX then
  local date = {}
  setmetatable(date, date)
-- Version:  VMMMRRRR; V-Major, M-Minor, R-Revision;  e.g. 5.45.321 == 50450321
  date.version = 20010001 -- 2.1.1
--#end -- not DATE_OBJECT_AFX
--[[ THE DATE OBJECT ]]--
  local dobj = {}
  dobj.__index = dobj
  dobj.__metatable = dobj
  -- shout invalid arg
  local function date_error_arg() return error("invalid argument(s)",0) end
  -- create new date object
  local function date_new(dn, df)
    return setmetatable({daynum=dn, dayfrc=df}, dobj)
  end

--#if not NO_LOCAL_TIME_SUPPORT then
  -- magic year table
  local date_epoch, yt;
  local function getequivyear(y)
    assert(not yt)
    yt = {}
    local de = date_epoch:copy()
    local dw, dy
    for _ = 0, 3000 do
      de:setyear(de:getyear() + 1, 1, 1)
      dy = de:getyear()
      dw = de:getweekday() * (isleapyear(dy) and  -1 or 1)
      if not yt[dw] then yt[dw] = dy end  --print(de)
      if yt[1] and yt[2] and yt[3] and yt[4] and yt[5] and yt[6] and yt[7] and yt[-1] and yt[-2] and yt[-3] and yt[-4] and yt[-5] and yt[-6] and yt[-7] then
        getequivyear = function(y)  return yt[ (weekday(makedaynum(y, 0, 1)) + 1) * (isleapyear(y) and  -1 or 1) ]  end
        return getequivyear(y)
      end
    end
  end
  -- TimeValue from date and time
  local function totv(y,m,d,h,r,s)
    return (makedaynum(y, m, d) - DATE_EPOCH) * SECPERDAY  + ((h*60 + r)*60 + s)
  end
  -- TimeValue from TimeTable
  local function tmtotv(tm)
    return tm and totv(tm.year, tm.month - 1, tm.day, tm.hour, tm.min, tm.sec)
  end
  -- Returns the bias in seconds of utc time daynum and dayfrc
  local function getbiasutc2(self)
    local y,m,d = breakdaynum(self.daynum)
    local h,r,s = breakdayfrc(self.dayfrc)
    local tvu = totv(y,m,d,h,r,s) -- get the utc TimeValue of date and time
    local tml = osdate("*t", tvu) -- get the local TimeTable of tvu
    if (not tml) or (tml.year > (y+1) or tml.year < (y-1)) then -- failed try the magic
      y = getequivyear(y)
      tvu = totv(y,m,d,h,r,s)
      tml = osdate("*t", tvu)
    end
    local tvl = tmtotv(tml)
    if tvu and tvl then
      return tvu - tvl, tvu, tvl
    else
      return error("failed to get bias from utc time")
    end
  end
  -- Returns the bias in seconds of local time daynum and dayfrc
  local function getbiasloc2(daynum, dayfrc)
    local tvu
    -- extract date and time
    local y,m,d = breakdaynum(daynum)
    local h,r,s = breakdayfrc(dayfrc)
    -- get equivalent TimeTable
    local tml = {year=y, month=m+1, day=d, hour=h, min=r, sec=s}
    -- get equivalent TimeValue
    local tvl = tmtotv(tml)

    local function chkutc()
      tml.isdst =  nil; local tvug = ostime(tml) if tvug and (tvl == tmtotv(osdate("*t", tvug))) then tvu = tvug return end
      tml.isdst = true; local tvud = ostime(tml) if tvud and (tvl == tmtotv(osdate("*t", tvud))) then tvu = tvud return end
      tvu = tvud or tvug
    end
    chkutc()
    if not tvu then
      tml.year = getequivyear(y)
      tvl = tmtotv(tml)
      chkutc()
    end
    return ((tvu and tvl) and (tvu - tvl)) or error("failed to get bias from local time"), tvu, tvl
  end
--#end -- not NO_LOCAL_TIME_SUPPORT

--#if not DATE_OBJECT_AFX then
  -- the date parser
  local strwalker = {} -- ^Lua regular expression is not as powerful as Perl$
  strwalker.__index = strwalker
  local function newstrwalker(s)return setmetatable({s=s, i=1, e=1, c=len(s)}, strwalker) end
  function strwalker:aimchr() return "\n" .. self.s .. "\n" .. rep(".",self.e-1) .. "^" end
  function strwalker:finish() return self.i > self.c  end
  function strwalker:back()  self.i = self.e return self  end
  function strwalker:restart() self.i, self.e = 1, 1 return self end
  function strwalker:match(s)  return (find(self.s, s, self.i)) end
  function strwalker:__call(s, f)-- print("strwalker:__call "..s..self:aimchr())
    local is, ie; is, ie, self[1], self[2], self[3], self[4], self[5] = find(self.s, s, self.i)
    if is then self.e, self.i = self.i, 1+ie; if f then f(unpack(self)) end return self end
  end
   local function date_parse(str)
    local y,m,d, h,r,s,  z,  w,u, j,  e,  x,c,  dn,df
    local sw = newstrwalker(gsub(gsub(str, "(%b())", ""),"^(%s*)","")) -- remove comment, trim leading space
    --local function error_out() print(y,m,d,h,r,s) end
    local function error_dup(q) --[[error_out()]] error("duplicate value: " .. (q or "") .. sw:aimchr()) end
    local function error_syn(q) --[[error_out()]] error("syntax error: " .. (q or "") .. sw:aimchr()) end
    local function error_inv(q) --[[error_out()]] error("invalid date: " .. (q or "") .. sw:aimchr()) end
    local function sety(q) y = y and error_dup() or tonumber(q); end
    local function setm(q) m = (m or w or j) and error_dup(m or w or j) or tonumber(q) end
    local function setd(q) d = d and error_dup() or tonumber(q) end
    local function seth(q) h = h and error_dup() or tonumber(q) end
    local function setr(q) r = r and error_dup() or tonumber(q) end
    local function sets(q) s = s and error_dup() or tonumber(q) end
    local function adds(q) s = s + tonumber(q) end
    local function setj(q) j = (m or w or j) and error_dup() or tonumber(q); end
    local function setz(q) z = (z ~= 0 and z) and error_dup() or q end
    local function setzn(zs,zn) zn = tonumber(zn); setz( ((zn<24) and (zn*60) or (mod(zn,100) + floor(zn/100) * 60))*( zs=='+' and -1 or 1) ) end
    local function setzc(zs,zh,zm) setz( ((tonumber(zh)*60) + tonumber(zm))*( zs=='+' and -1 or 1) ) end

    if not (sw("^(%d%d%d%d)",sety) and (sw("^(%-?)(%d%d)%1(%d%d)",function(_,a,b) setm(tonumber(a)); setd(tonumber(b)) end) or sw("^(%-?)[Ww](%d%d)%1(%d?)",function(_,a,b) w, u = tonumber(a), tonumber(b or 1) end) or sw("^%-?(%d%d%d)",setj) or sw("^%-?(%d%d)",function(a) setm(a);setd(1) end))
    and ((sw("^%s*[Tt]?(%d%d):?",seth) and sw("^(%d%d):?",setr) and sw("^(%d%d)",sets) and sw("^(%.%d+)",adds))
      or sw:finish() or (sw"^%s*$" or sw"^%s*[Zz]%s*$" or sw("^%s-([%+%-])(%d%d):?(%d%d)%s*$",setzc) or sw("^%s*([%+%-])(%d%d)%s*$",setzn))
      )  )
    then --print(y,m,d,h,r,s,z,w,u,j)
    sw:restart(); y,m,d,h,r,s,z,w,u,j = nil,nil,nil,nil,nil,nil,nil,nil,nil,nil
      repeat -- print(sw:aimchr())
        if sw("^[tT:]?%s*(%d%d?):",seth) then --print("$Time")
          _ = sw("^%s*(%d%d?)",setr) and sw("^%s*:%s*(%d%d?)",sets) and sw("^(%.%d+)",adds)
        elseif sw("^(%d+)[/\\%s,-]?%s*") then --print("$Digits")
          x, c = tonumber(sw[1]), len(sw[1])
          if (x >= 70) or (m and d and (not y)) or (c > 3) then
            sety( x + ((x >= 100 or c>3)and 0 or 1900) )
          else
            if m then setd(x) else m = x end
          end
        elseif sw("^(%a+)[/\\%s,-]?%s*") then --print("$Words")
          x = sw[1]
          if inlist(x, sl_months,   2, sw) then
            if m and (not d) and (not y) then d, m = m, false end
            setm(mod(sw[0],12)+1)
          elseif inlist(x, sl_timezone, 2, sw) then
            c = fix(sw[0]) -- ignore gmt and utc
            if c ~= 0 then setz(c, x) end
          elseif not inlist(x, sl_weekdays, 2, sw) then
            sw:back()
            -- am pm bce ad ce bc
            if sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*[Ee]%s*(%2)%s*") or sw("^([bB])%s*(%.?)%s*[Cc]%s*(%2)%s*") then
              e = e and error_dup() or -1
            elseif sw("^([aA])%s*(%.?)%s*[Dd]%s*(%2)%s*") or sw("^([cC])%s*(%.?)%s*[Ee]%s*(%2)%s*") then
              e = e and error_dup() or 1
            elseif sw("^([PApa])%s*(%.?)%s*[Mm]?%s*(%2)%s*") then
              x = lwr(sw[1]) -- there should be hour and it must be correct
              if (not h) or (h > 12) or (h < 0) then return error_inv() end
              if x == 'a' and h == 12 then h = 0 end -- am
              if x == 'p' and h ~= 12 then h = h + 12 end -- pm
            else error_syn() end
          end
        elseif not(sw("^([+-])(%d%d?):(%d%d)",setzc) or sw("^([+-])(%d+)",setzn) or sw("^[Zz]%s*$")) then -- sw{"([+-])",{"(%d%d?):(%d%d)","(%d+)"}}
          error_syn("?")
        end
      sw("^%s*")  until sw:finish()
    --else print("$Iso(Date|Time|Zone)")
    end
    -- if date is given, it must be complete year, month & day
    if (not y and not h) or ((m and not d) or (d and not m)) or ((m and w) or (m and j) or (j and w)) then return error_inv("!") end
    -- fix month
    if m then m = m - 1 end
    -- fix year if we are on BCE
    if e and e < 0 and y > 0 then y = 1 - y end
    --  create date object
    dn = (y and ((w and makedaynum_isoywd(y,w,u)) or (j and makedaynum(y, 0, j)) or makedaynum(y, m, d))) or DAYNUM_DEF
    df = makedayfrc(h or 0, r or 0, s or 0, 0) + ((z or 0)*TICKSPERMIN)
    --print("Zone",h,r,s,z,m,d,y,df)
    return date_new(dn, df) -- no need to :normalize();
   end
  local function date_fromtable(v)
    local y, m, d = fix(v.year), getmontharg(v.month), fix(v.day)
    local h, r, s, t = tonumber(v.hour), tonumber(v.min), tonumber(v.sec), tonumber(v.ticks)
    -- atleast there is time or complete date
    if (y or m or d) and (not(y and m and d)) then return error("incomplete table")  end
    return (y or h or r or s or t) and date_new(y and makedaynum(y, m, d) or DAYNUM_DEF, makedayfrc(h or 0, r or 0, s or 0, t or 0))
  end
  local tmap = {
    ['number'] = function(v) return date_epoch:copy():addseconds(v) end,
    ['string'] = function(v) return date_parse(v) end,
    ['boolean']= function(v) return date_fromtable(osdate(v and "!*t" or "*t")) end,
    ['table']  = function(v) local ref = getmetatable(v) == dobj; return ref and v or date_fromtable(v), ref end
  }
  local function date_getdobj(v)
    local o, r = (tmap[type(v)] or fnil)(v);
    return (o and o:normalize() or error"invalid date time value"), r -- if r is true then o is a reference to a date obj
  end
--#end -- not DATE_OBJECT_AFX
  local function date_from(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
    local y, m, d = fix(arg1), getmontharg(arg2), fix(arg3)
    local h, r, s, t = tonumber(arg4 or 0), tonumber(arg5 or 0), tonumber(arg6 or 0), tonumber(arg7 or 0)
    if y and m and d and h and r and s and t then
      return date_new(makedaynum(y, m, d), makedayfrc(h, r, s, t)):normalize()
    else
      return date_error_arg()
    end
  end

 --[[ THE DATE OBJECT METHODS ]]--
  function dobj:normalize()
    local dn, df = fix(self.daynum), self.dayfrc
    self.daynum, self.dayfrc = dn + floor(df/TICKSPERDAY), mod(df, TICKSPERDAY)
    return (dn >= DAYNUM_MIN and dn <= DAYNUM_MAX) and self or error("date beyond imposed limits:"..self)
  end

  function dobj:getdate()  local y, m, d = breakdaynum(self.daynum) return y, m+1, d end
  function dobj:gettime()  return breakdayfrc(self.dayfrc) end

  function dobj:getclockhour() local h = self:gethours() return h>12 and mod(h,12) or (h==0 and 12 or h) end

  function dobj:getyearday() return yearday(self.daynum) + 1 end
  function dobj:getweekday() return weekday(self.daynum) + 1 end   -- in lua weekday is sunday = 1, monday = 2 ...

  function dobj:getyear()   local r,_,_ = breakdaynum(self.daynum)  return r end
  function dobj:getmonth() local _,r,_ = breakdaynum(self.daynum)  return r+1 end-- in lua month is 1 base
  function dobj:getday()   local _,_,r = breakdaynum(self.daynum)  return r end
  function dobj:gethours()  return mod(floor(self.dayfrc/TICKSPERHOUR),HOURPERDAY) end
  function dobj:getminutes()  return mod(floor(self.dayfrc/TICKSPERMIN), MINPERHOUR) end
  function dobj:getseconds()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)  end
  function dobj:getfracsec()  return mod(floor(self.dayfrc/TICKSPERSEC ),SECPERMIN)+(mod(self.dayfrc,TICKSPERSEC)/TICKSPERSEC) end
  function dobj:getticks(u)  local x = mod(self.dayfrc,TICKSPERSEC) return u and ((x*u)/TICKSPERSEC) or x  end

  function dobj:getweeknumber(wdb)
    local wd, yd = weekday(self.daynum), yearday(self.daynum)
    if wdb then
      wdb = tonumber(wdb)
      if wdb then
        wd = mod(wd-(wdb-1),7)-- shift the week day base
      else
        return date_error_arg()
      end
    end
    return (yd < wd and 0) or (floor(yd/7) + ((mod(yd, 7)>=wd) and 1 or 0))
  end

  function dobj:getisoweekday() return mod(weekday(self.daynum)-1,7)+1 end   -- sunday = 7, monday = 1 ...
  function dobj:getisoweeknumber() return (isowy(self.daynum)) end
  function dobj:getisoyear() return isoy(self.daynum)  end
  function dobj:getisodate()
    local w, y = isowy(self.daynum)
    return y, w, self:getisoweekday()
  end
  function dobj:setisoyear(y, w, d)
    local cy, cw, cd = self:getisodate()
    if y then cy = fix(tonumber(y))end
    if w then cw = fix(tonumber(w))end
    if d then cd = fix(tonumber(d))end
    if cy and cw and cd then
      self.daynum = makedaynum_isoywd(cy, cw, cd)
      return self:normalize()
    else
      return date_error_arg()
    end
  end

  function dobj:setisoweekday(d)    return self:setisoyear(nil, nil, d) end
  function dobj:setisoweeknumber(w,d)  return self:setisoyear(nil, w, d)  end

  function dobj:setyear(y, m, d)
    local cy, cm, cd = breakdaynum(self.daynum)
    if y then cy = fix(tonumber(y))end
    if m then cm = getmontharg(m)  end
    if d then cd = fix(tonumber(d))end
    if cy and cm and cd then
      self.daynum  = makedaynum(cy, cm, cd)
      return self:normalize()
    else
      return date_error_arg()
    end
  end

  function dobj:setmonth(m, d)return self:setyear(nil, m, d) end
  function dobj:setday(d)    return self:setyear(nil, nil, d) end

  function dobj:sethours(h, m, s, t)
    local ch,cm,cs,ck = breakdayfrc(self.dayfrc)
    ch, cm, cs, ck = tonumber(h or ch), tonumber(m or cm), tonumber(s or cs), tonumber(t or ck)
    if ch and cm and cs and ck then
      self.dayfrc = makedayfrc(ch, cm, cs, ck)
      return self:normalize()
    else
      return date_error_arg()
    end
  end

  function dobj:setminutes(m,s,t)  return self:sethours(nil,   m,   s, t) end
  function dobj:setseconds(s, t)  return self:sethours(nil, nil,   s, t) end
  function dobj:setticks(t)    return self:sethours(nil, nil, nil, t) end

  function dobj:spanticks()  return (self.daynum*TICKSPERDAY + self.dayfrc) end
  function dobj:spanseconds()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERSEC  end
  function dobj:spanminutes()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERMIN  end
  function dobj:spanhours()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERHOUR end
  function dobj:spandays()  return (self.daynum*TICKSPERDAY + self.dayfrc)/TICKSPERDAY  end

  function dobj:addyears(y, m, d)
    local cy, cm, cd = breakdaynum(self.daynum)
    if y then y = fix(tonumber(y))else y = 0 end
    if m then m = fix(tonumber(m))else m = 0 end
    if d then d = fix(tonumber(d))else d = 0 end
    if y and m and d then
      self.daynum  = makedaynum(cy+y, cm+m, cd+d)
      return self:normalize()
    else
      return date_error_arg()
    end
  end

  function dobj:addmonths(m, d)
    return self:addyears(nil, m, d)
  end

  local function dobj_adddayfrc(self,n,pt,pd)
    n = tonumber(n)
    if n then
      local x = floor(n/pd);
      self.daynum = self.daynum + x;
      self.dayfrc = self.dayfrc + (n-x*pd)*pt;
      return self:normalize()
    else
      return date_error_arg()
    end
  end
  function dobj:adddays(n)  return dobj_adddayfrc(self,n,TICKSPERDAY,1) end
  function dobj:addhours(n)  return dobj_adddayfrc(self,n,TICKSPERHOUR,HOURPERDAY) end
  function dobj:addminutes(n)  return dobj_adddayfrc(self,n,TICKSPERMIN,MINPERDAY)  end
  function dobj:addseconds(n)  return dobj_adddayfrc(self,n,TICKSPERSEC,SECPERDAY)  end
  function dobj:addticks(n)  return dobj_adddayfrc(self,n,1,TICKSPERDAY) end
  local tvspec = {
    -- Abbreviated weekday name (Sun)
    ['%a']=function(self) return sl_weekdays[weekday(self.daynum) + 7] end,
    -- Full weekday name (Sunday)
    ['%A']=function(self) return sl_weekdays[weekday(self.daynum)] end,
    -- Abbreviated month name (Dec)
    ['%b']=function(self) return sl_months[self:getmonth() - 1 + 12] end,
    -- Full month name (December)
    ['%B']=function(self) return sl_months[self:getmonth() - 1] end,
    -- Year/100 (19, 20, 30)
    ['%C']=function(self) return fmt("%.2d", fix(self:getyear()/100)) end,
    -- The day of the month as a number (range 1 - 31)
    ['%d']=function(self) return fmt("%.2d", self:getday())  end,
    -- year for ISO 8601 week, from 00 (79)
    ['%g']=function(self) return fmt("%.2d", mod(self:getisoyear() ,100)) end,
    -- year for ISO 8601 week, from 0000 (1979)
    ['%G']=function(self) return fmt("%.4d", self:getisoyear()) end,
    -- same as %b
    ['%h']=function(self) return self:fmt0("%b") end,
    -- hour of the 24-hour day, from 00 (06)
    ['%H']=function(self) return fmt("%.2d", self:gethours()) end,
    -- The  hour as a number using a 12-hour clock (01 - 12)
    ['%I']=function(self) return fmt("%.2d", self:getclockhour()) end,
    -- The day of the year as a number (001 - 366)
    ['%j']=function(self) return fmt("%.3d", self:getyearday())  end,
    -- Month of the year, from 01 to 12
    ['%m']=function(self) return fmt("%.2d", self:getmonth())  end,
    -- Minutes after the hour 55
    ['%M']=function(self) return fmt("%.2d", self:getminutes())end,
    -- AM/PM indicator (AM)
    ['%p']=function(self) return sl_meridian[self:gethours() > 11 and 1 or -1] end, --AM/PM indicator (AM)
    -- The second as a number (59, 20 , 01)
    ['%S']=function(self) return fmt("%.2d", self:getseconds())  end,
    -- ISO 8601 day of the week, to 7 for Sunday (7, 1)
    ['%u']=function(self) return self:getisoweekday() end,
    -- Sunday week of the year, from 00 (48)
    ['%U']=function(self) return fmt("%.2d", self:getweeknumber()) end,
    -- ISO 8601 week of the year, from 01 (48)
    ['%V']=function(self) return fmt("%.2d", self:getisoweeknumber()) end,
    -- The day of the week as a decimal, Sunday being 0
    ['%w']=function(self) return self:getweekday() - 1 end,
    -- Monday week of the year, from 00 (48)
    ['%W']=function(self) return fmt("%.2d", self:getweeknumber(2)) end,
    -- The year as a number without a century (range 00 to 99)
    ['%y']=function(self) return fmt("%.2d", mod(self:getyear() ,100)) end,
    -- Year with century (2000, 1914, 0325, 0001)
    ['%Y']=function(self) return fmt("%.4d", self:getyear()) end,
    -- Time zone offset, the date object is assumed local time (+1000, -0230)
    ['%z']=function(self) local b = -self:getbias(); local x = abs(b); return fmt("%s%.4d", b < 0 and "-" or "+", fix(x/60)*100 + floor(mod(x,60))) end,
    -- Time zone name, the date object is assumed local time
    ['%Z']=function(self) return self:gettzname() end,
    -- Misc --
    -- Year, if year is in BCE, prints the BCE Year representation, otherwise result is similar to "%Y" (1 BCE, 40 BCE)
    ['%\b']=function(self) local x = self:getyear() return fmt("%.4d%s", x>0 and x or (-x+1), x>0 and "" or " BCE") end,
    -- Seconds including fraction (59.998, 01.123)
    ['%\f']=function(self) local x = self:getfracsec() return fmt("%s%.9f",x >= 10 and "" or "0", x) end,
    -- percent character %
    ['%%']=function(self) return "%" end,
    -- Group Spec --
    -- 12-hour time, from 01:00:00 AM (06:55:15 AM); same as "%I:%M:%S %p"
    ['%r']=function(self) return self:fmt0("%I:%M:%S %p") end,
    -- hour:minute, from 01:00 (06:55); same as "%I:%M"
    ['%R']=function(self) return self:fmt0("%I:%M")  end,
    -- 24-hour time, from 00:00:00 (06:55:15); same as "%H:%M:%S"
    ['%T']=function(self) return self:fmt0("%H:%M:%S") end,
    -- month/day/year from 01/01/00 (12/02/79); same as "%m/%d/%y"
    ['%D']=function(self) return self:fmt0("%m/%d/%y") end,
    -- year-month-day (1979-12-02); same as "%Y-%m-%d"
    ['%F']=function(self) return self:fmt0("%Y-%m-%d") end,
    -- The preferred date and time representation;  same as "%x %X"
    ['%c']=function(self) return self:fmt0("%x %X") end,
    -- The preferred date representation, same as "%a %b %d %\b"
    ['%x']=function(self) return self:fmt0("%a %b %d %\b") end,
    -- The preferred time representation, same as "%H:%M:%\f"
    ['%X']=function(self) return self:fmt0("%H:%M:%\f") end,
    -- GroupSpec --
    -- Iso format, same as "%Y-%m-%dT%T"
    ['${iso}'] = function(self) return self:fmt0("%Y-%m-%dT%T") end,
    -- http format, same as "%a, %d %b %Y %T GMT"
    ['${http}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
    -- ctime format, same as "%a %b %d %T GMT %Y"
    ['${ctime}'] = function(self) return self:fmt0("%a %b %d %T GMT %Y") end,
    -- RFC850 format, same as "%A, %d-%b-%y %T GMT"
    ['${rfc850}'] = function(self) return self:fmt0("%A, %d-%b-%y %T GMT") end,
    -- RFC1123 format, same as "%a, %d %b %Y %T GMT"
    ['${rfc1123}'] = function(self) return self:fmt0("%a, %d %b %Y %T GMT") end,
    -- asctime format, same as "%a %b %d %T %Y"
    ['${asctime}'] = function(self) return self:fmt0("%a %b %d %T %Y") end,
  }
  function dobj:fmt0(str) return (gsub(str, "%%[%a%%\b\f]", function(x) local f = tvspec[x];return (f and f(self)) or x end)) end
  function dobj:fmt(str)
    str = str or self.fmtstr or fmtstr
    return self:fmt0((gmatch(str, "${%w+}")) and (gsub(str, "${%w+}", function(x)local f=tvspec[x];return (f and f(self)) or x end)) or str)
  end

  function dobj.__lt(a, b) if (a.daynum == b.daynum) then return (a.dayfrc < b.dayfrc) else return (a.daynum < b.daynum) end end
  function dobj.__le(a, b) if (a.daynum == b.daynum) then return (a.dayfrc <= b.dayfrc) else return (a.daynum <= b.daynum) end end
  function dobj.__eq(a, b)return (a.daynum == b.daynum) and (a.dayfrc == b.dayfrc) end
  function dobj.__sub(a,b)
    local d1, d2 = date_getdobj(a), date_getdobj(b)
    local d0 = d1 and d2 and date_new(d1.daynum - d2.daynum, d1.dayfrc - d2.dayfrc)
    return d0 and d0:normalize()
  end
  function dobj.__add(a,b)
    local d1, d2 = date_getdobj(a), date_getdobj(b)
    local d0 = d1 and d2 and date_new(d1.daynum + d2.daynum, d1.dayfrc + d2.dayfrc)
    return d0 and d0:normalize()
  end
  function dobj.__concat(a, b) return tostring(a) .. tostring(b) end
  function dobj:__tostring() return self:fmt() end

  function dobj:copy() return date_new(self.daynum, self.dayfrc) end

--[[ THE LOCAL DATE OBJECT METHODS ]]--
  function dobj:tolocal()
    local dn,df = self.daynum, self.dayfrc
    local bias  = getbiasutc2(self)
    if bias then
      -- utc = local + bias; local = utc - bias
      self.daynum = dn
      self.dayfrc = df - bias*TICKSPERSEC
      return self:normalize()
    else
      return nil
    end
  end

  function dobj:toutc()
    local dn,df = self.daynum, self.dayfrc
    local bias  = getbiasloc2(dn, df)
    if bias then
      -- utc = local + bias;
      self.daynum = dn
      self.dayfrc = df + bias*TICKSPERSEC
      return self:normalize()
    else
      return nil
    end
  end

  function dobj:getbias()  return (getbiasloc2(self.daynum, self.dayfrc))/SECPERMIN end

  function dobj:gettzname()
    local _, tvu, _ = getbiasloc2(self.daynum, self.dayfrc)
    return tvu and osdate("%Z",tvu) or ""
  end

--#if not DATE_OBJECT_AFX then
  function date.time(h, r, s, t)
    h, r, s, t = tonumber(h or 0), tonumber(r or 0), tonumber(s or 0), tonumber(t or 0)
    if h and r and s and t then
       return date_new(DAYNUM_DEF, makedayfrc(h, r, s, t))
    else
      return date_error_arg()
    end
  end

  function date:__call(arg1, ...)
    local arg_count = select("#", ...) + (arg1 == nil and 0 or 1)
    if arg_count  > 1 then return (date_from(arg1, ...))
    elseif arg_count == 0 then return (date_getdobj(false))
    else local o, r = date_getdobj(arg1);  return r and o:copy() or o end
  end

  date.diff = dobj.__sub

  function date.isleapyear(v)
    local y = fix(v);
    if not y then
      y = date_getdobj(v)
      y = y and y:getyear()
    end
    return isleapyear(y+0)
  end

  function date.epoch() return date_epoch:copy()  end

  function date.isodate(y,w,d) return date_new(makedaynum_isoywd(y + 0, w and (w+0) or 1, d and (d+0) or 1), 0)  end

-- Internal functions
  function date.fmt(str) if str then fmtstr = str end; return fmtstr end
  function date.daynummin(n)  DAYNUM_MIN = (n and n < DAYNUM_MAX) and n or DAYNUM_MIN  return n and DAYNUM_MIN or date_new(DAYNUM_MIN, 0):normalize()end
  function date.daynummax(n)  DAYNUM_MAX = (n and n > DAYNUM_MIN) and n or DAYNUM_MAX return n and DAYNUM_MAX or date_new(DAYNUM_MAX, 0):normalize()end
  function date.ticks(t) if t then setticks(t) end return TICKSPERSEC  end
--#end -- not DATE_OBJECT_AFX

  -- local tm = osdate("!*t", 0);
  -- if tm then
  --   date_epoch = date_new(makedaynum(tm.year, tm.month - 1, tm.day), makedayfrc(tm.hour, tm.min, tm.sec, 0))
  --   -- the distance from our epoch to os epoch in daynum
  --   DATE_EPOCH = date_epoch and date_epoch:spandays()
  -- else -- error will be raise only if called!
  --   date_epoch = setmetatable({},{__index = function() error("failed to get the epoch date") end})
  -- end

--#if not DATE_OBJECT_AFX then
return date
--#else
--$return date_from
--#end

--[[
  This file is part of Lua-FaCES (https://github.com/pakozm/lua-faces)

  Copyright 2015, Francisco Zamora-Martinez
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
]]

local tuple = require "tuple"

-- module faces
local faces = {}

local globals = {}
_G = setmetatable(_G, {
                    __index=function(self,k) return rawget(self,k) or globals[k] end,
                    
                    __newindex=function(self,k,v)
                      assert(not globals[k], ("Forbidden declaration of reserved global %s"):format(k))
                      rawset(self,k,v)
                    end,
})

----------------------
-- STATIC FUNCTIONS --
----------------------

-- inspired by Penlight string_lambda:
-- http://stevedonovan.github.io/Penlight/api/libraries/pl.utils.html#string_lambda
local lambda
do
  local memory = {}
  lambda = setmetatable({ clear = function() memory = {} end, },
    {
      __call = function(self,fstr)
        local fun = memory[fstr]
        if not fun then
          local args,code = fstr:match("^%s*|(.+)|(.+)$")
          assert(args and code, "Needs args and code sections, e.g., |args|code")
          local fun_src = ("return function(%s) return %s end"):format(args,code)
          fun = assert(loadstring(fun_src))()
          memory[fstr] = fun
        end
        return fun      
      end,
                       })
end

-- transform a user function string into a lambda function
local function lambda_transform(func_str)
  return function(vars)
    local values,keys = {},{}
    for k,v in pairs(vars) do
      values[#values+1] = v
      keys[#keys+1] = k
    end
    local code = ('|%s|%s'):format(table.concat(keys,","),func_str)
    local f = lambda(code)
    return f(table.unpack(values))
  end
end

local function get_user_func(user_func)
  -- user_func receives one argument: vars
  if type(user_func) == "string" then
    user_func = lambda_transform(user_func)
  end
  return user_func
end

globals.u = function(func_str)
  local f = get_user_func(func_str)
  return setmetatable({ __user_function__ = true },
    { __call=function(_, ...) return f(...) end })
end

-- converts to in-mutable the given table argument
local function inmutable(tbl)
  return setmetatable({}, {
      __index = function(_,k) return tbl[k] end,
      __newindex = function() error("Unable to modify an in-mutable table") end,
      __len = function() return #tbl end,
      __ipairs = function() return ipairs(tbl) end,
      __pairs = function() return pairs(tbl) end,
  })
end

-- pattern matching between a fact and the rule pattern
local function fact_match(fact, pattern)
  if #fact ~= #pattern then return false end
  local fact_str = tostring(fact):gsub('"', '')
  local pat_str = tostring(pattern):gsub("%.", "[^,]"):gsub('"', ''):
    gsub("%$%?[^%s,]+", "tuple%%b{}"):gsub("%?[^%s,]+", "[^,]*")
  -- print(fact_str, pat_str, fact_str:find(pat_str))
  assert(not pat_str:find("%?"),
         string.format("Incorrect variable name in pattern: %s",
                       tostring(pattern)))
  -- print(fact_str, pat_str, fact_str:find(pat_str))
  return fact_str:find(pat_str)
end

-- check that the fact string doesn't contain forbidden symbols
local function check_fact_strings(fact)
  for i=1,#fact do
    local tt = type(fact[i])
    if tt == "table" then
      check_fact_strings(fact[i])
    elseif tt == "string" then
      assert(not fact[i]:find("[%$%.%-%,%+%?%(%)%{%}%[%]]"),
             string.format("Forbidden use of the following symbols in fact '%s': $ . - , + ? ( ) { } [ ]",
                           tostring(tuple(fact))))
    end
  end
end

-- forward declarations
local replace_variables
local replace_user_functions
do
  local function replace(vi, vars)
    local new_v = {}
    for j,vj in ipairs(vi) do
      local tt = type(vj)
      if tt == "string" then
        local varname = vj:match("%?([^%s]+)")
        if varname then
          new_v[j] = assert(vars[varname],
                            string.format("Unable to find variable: %s", varname))
        else
          new_v[j] = vj
        end
      elseif tt == "table" then
        new_v[j] = replace(vj, vars)
      else
        new_v[j] = vj
      end
    end
    return new_v
  end

  replace_variables = function(args, vars)
    local new_args = {}
    for i,vi in ipairs(args) do
      new_args[i] = replace(vi, vars)
    end
    return new_args
  end

  replace_user_functions = function(args, vars)
    local result = {}
    for i,v in pairs(args) do
      local tt = type(v)
      if tt == "function" or tt == "table" and v.__user_function__ then
        result[i] = v(vars)
      elseif tt == "table" then
        result[i] = replace_user_functions(v, vars)
      else
        result[i] = v
      end
    end
    return result
  end
end

-- forward declaration
local assign_variables
do
  local function assign_fact_vars(vars, pat, fact, var_matches)
    for j,v in ipairs(pat) do
      local tt = type(v)
      if tt == "string" then
        local varname = v:match("%?([^%s]+)")
        if varname then
          local value = fact[j]
          if not var_matches[varname] or var_matches[varname](value) then
            if not vars[varname] then
              vars[varname] = value
            else
              if vars[varname] ~= value then return false end
            end
          else
            return false
          end
        end
      elseif tt == "table" then
        if not assign_fact_vars(vars, v, fact[j], var_matches) then
          return false
        end
      end
    end
    return true
  end

  assign_variables = function(self, vars, patterns, sequence, var_matches,
                              user_clauses, fact_vars)
    for i,pat in ipairs(patterns) do
      local fid  = sequence[i]
      local fact = self.fact_list[fid]
      if not assign_fact_vars(vars, pat, fact, var_matches) then return false end
    end
    for vname,i in pairs(fact_vars) do vars[vname] = sequence[i] end
    local inmutable_vars = inmutable(vars)
    for _,func in ipairs(user_clauses) do
      if not func(inmutable_vars) then return false end
    end
    return true
  end
end

-- returns an iterator function which enumerates all possible combinations
-- (Cartesian product) between all the given array arguments
local function enumerate(...)
  local function f(seq, tbl, ...)
    if tbl == nil and select('#', ...) == 0 then
      if #seq > 0 then coroutine.yield(tuple(seq)) end
    else
      if tbl ~= nil then
        if #seq > 0 then
          for i,v in ipairs(tbl) do
            f(seq .. tuple(v), ...)
          end
        else
          for i,v in ipairs(tbl) do
            f(tuple{v}, ...)
          end
        end
      end
    end
  end
  local args = table.pack(...)
  return coroutine.wrap(function() f({}, table.unpack(args)) end)
end

-- traverses all possible rules with all possible matches and introduces into
-- the agenda whose clause sequences which weren't entailed before and are valid
-- for the analyzed rule
local function regenerate_agenda(self)
  self.needs_regenerate_agenda = false
  local entailed = self.entailed
  local matches = self.matches
  local agenda = {}
  for rule_name,rule in pairs(self.kb_table) do
    local rule_entailements = entailed[rule_name] or {}
    local combinations = {}
    local variables = {}
    if #matches[rule_name] == #rule.patterns then
      for sequence in enumerate(table.unpack(matches[rule_name])) do
        if not rule_entailements[sequence] then
          local seq_vars = {}
          if assign_variables(self, seq_vars, rule.patterns, sequence,
                              rule.var_matches, rule.user_clauses,
                              rule.fact_vars) then
            table.insert(combinations, sequence)
            table.insert(variables, seq_vars)
          end
        end
      end
      if #combinations > 0 then
        table.insert(agenda, {
                       rule_name = rule_name,
                       salience = rule.salience,
                       combinations = combinations,
                       variables = variables,
        })
      end
    end
  end
  table.sort(agenda, function(a,b) return a.salience > b.salience end)
  self.rules_agenda = agenda
end

-- look-ups for the rule with best salience, and returns the rule name and its
-- pattern matching arguments
local function take_best_rule(self)
  if self.needs_regenerate_agenda then regenerate_agenda(self) end
  local rules_agenda = self.rules_agenda
  if #rules_agenda > 0 then
    local rule_data = rules_agenda[1]
    local args = assert(table.remove(rule_data.combinations, 1),
                        "Found empty LHS args :'(")
    local vars = assert(table.remove(rule_data.variables, 1),
                        "Found empty LHS vars :'(")
    if #rule_data.combinations == 0 then table.remove(rules_agenda, 1) end
    local rule_name = rule_data.rule_name
    return rule_name,args,vars
  end
end

-- executes the given rule name with the given pattern matching arguments
local function fire_rule(self, rule_name, args, vars)
  local rule = self.kb_table[rule_name]
  self.entailed[rule_name] = self.entailed[rule_name] or {}
  self.entailed[rule_name][args] = true
  for i,v in ipairs(args) do self.fact_entailment[v] = args end
  -- execute rule actions
  for _,action in ipairs(rule.actions) do
    action(inmutable(vars))
  end
end

-- binary search in a sorted array of numbers, where tbl is the array, v is the
-- look-up value, p is the start position (by default it is 1) and q the end
-- position (by default it is #tbl)
local function bsearch(tbl, v, p, q)
  p, q = p or 1, q or #tbl
  if p <= q then
    local n = q - p + 1
    if n < 30 then
      for i=p,q do if tbl[i] == v then return true end end
    else
      local m = math.floor((p+q)/2)
      if tbl[m] == v then
        return true
      elseif v < tbl[m] then
        return bsearch(tbl, v, p, m-1)
      else
        return bsearch(tbl, v, m+1, q)
      end
    end
  end
end

-- updates possible matches with the information given by one new fact
local function update_forward_chaining_with_assert_fact(self, fact)
  local fid     = self.fact_map[fact]
  local matches = self.matches
  for rule_name,rule in pairs(self.kb_table) do
    local rule_matches = matches[rule_name] or {}
    matches[rule_name] = rule_matches
    for i,pat in ipairs(rule.patterns) do
      if fact_match(fact, pat) then
        rule_matches[i] = rule_matches[i] or {}
        table.insert(rule_matches[i], fid)
        table.sort(rule_matches[i])
      end
    end
  end
  self.needs_regenerate_agenda = true
end

-- updates possible matches after retracting one fact
local function update_forward_chaining_with_retract_fact(self, fact)
  local fid     = self.fact_map[fact]
  local matches = self.matches
  for rule_name,rule in pairs(self.kb_table) do
    local rule_matches = matches[rule_name]
    for i,pat in ipairs(rule.patterns) do
      if rule_matches[i] then
        if bsearch(rule_matches[i], fid) then
          new_rule_matches = {}
          for j,v in ipairs(rule_matches[i]) do
            if v ~= fid then table.insert(new_rule_matches, v) end
          end
          table.sort(new_rule_matches)
          rule_matches[i] = new_rule_matches
        end
      end
    end
  end
  for _,sequence in ipairs(self.fact_entailment[fid] or {}) do
    self.entailed[sequence] = nil
  end
  self.fact_entailment[fid] = nil
  self.needs_regenerate_agenda = true
end

-- updates possible matches after introducing a new rule
local function update_forward_chaining_with_rule(self, rule_name, rule)
  local fid          = self.fact_map[fact]
  local matches      = self.matches
  local rule_matches = {}
  for i,pat in ipairs(rule.patterns) do
    for fid,fact in pairs(self.fact_list) do
      if fact_match(fact, pat) then
        rule_matches[i] = rule_matches[i] or {}
        table.insert(rule_matches[i], fid)
        table.sort(rule_matches[i])
      end
    end
  end
  matches[rule_name] = rule_matches
  self.needs_regenerate_agenda = true
end

-------------
-- METHODS --
-------------

local faces_methods = {}

-- initializes the facts database
function faces_methods:clear()
  self.needs_regenerate_agenda = false
  -- counter index
  self.fact_idx = 0
  -- global memory for data
  self.fact_map = {}
  self.fact_list = {}
  -- agenda with lists of rules and its matching preconditions, sorted by
  -- salience
  self.rules_agenda = {}
  -- list of entailed preconditions, indexed by rule name
  self.entailed = {}
  -- list of entailed sequences related with every fact id
  self.fact_entailment = {}
  -- match rules dictionary, stores:
  --   rule_name = { pos1 = { fid1, fid2, ... }, pos2 = { ... } }
  -- where pos are rule LHS which matches with indicated fact ids
  self.matches = {}
  --
  self:fassert{ "initial fact" }
end

-- introduces a new fact into the database
function faces_methods:fassert(fact, ...)
  if fact ~= nil then
    assert(type(fact) == "table", "A table argument is expected")
    check_fact_strings(fact)
    local fact = tuple(fact)
    if not self.fact_map[fact] then
      self.fact_idx = self.fact_idx + 1
      self.fact_list[self.fact_idx] = fact
      self.fact_map[fact] = self.fact_idx
      -- executes a partial step of forward chaining with all rules affected by
      -- the given fact
      update_forward_chaining_with_assert_fact(self, fact)
      return self.fact_map[fact],self:fassert(...)
    else
      return self.fact_map[fact],self:fassert(...)
    end
  end
end

-- removes a fact from the database
function faces_methods:retract(...)
  for i=1,select('#',...) do
    local v = select(i,...)
    if v == "*" then
      self.needs_regenerate_agenda = true
      -- retract all facts
      for idx,f in pairs(self.fact_list) do
        self.fact_list[idx] = nil
        self.fact_map[f] = nil
      end
      self.matches = {}
      self.rules_agenda = {}
      self.entailed = {}
      self.fact_entailment = {}
    else
      -- retract a given fact
      assert(type(v) == "number", "Expected fact number or '*' string")
      local f = self.fact_list[v]
      if f then
        -- executes a partial step of forward chaining with all rules affected by
        -- the given fact
        update_forward_chaining_with_retract_fact(self, f)
        self.fact_list[v] = nil
        self.fact_map[f] = nil
      else
        error("Unable to find fact " .. v)
      end
    end
  end
end

-- shows in screen all the available facts
function faces_methods:facts()
  local facts = {}
  for i,v in pairs(self.fact_list) do
    table.insert(facts, {i,v})
  end
  table.sort(facts, function(a,b) return a[1]<b[1] end)
  print("# Facts list")
  for _,v in ipairs(facts) do
    print("f-" .. v[1], v[2])
  end
  print(string.format("# For a total of %d facts", #facts))
end

-- shows in screen all the available rules
function faces_methods:rules()
  local rules = {}
  for i,v in pairs(self.kb_table) do
    table.insert(rules, {i,v})
  end
  table.sort(rules, function(a,b) return a[1]<b[1] end)
  print("# Rules list")
  for _,v in ipairs(rules) do
    print(v[1], "salience:", v[2].salience)
  end
end

-- shows the agenda in screen
function faces_methods:agenda()
  if self.needs_regenerate_agenda then regenerate_agenda(self) end
  print("# Agenda")
  local n=0
  for _,v in ipairs(self.rules_agenda) do
    local rule_name    = v.rule_name
    local salience     = v.salience
    local combinations = v.combinations
    for _,seq in ipairs(combinations) do
      n=n+1
      print(tostring(salience), rule_name, tostring(seq))
    end
  end
  print(string.format("# For a total of %d activations", n))
end

-- executes at most n iterations, being by default n=infinity
function faces_methods:run(n)
  n = n or math.huge
  local i=0
  repeat
    local data = table.pack( take_best_rule(self) )
    if data[1] then fire_rule(self, table.unpack(data) ) i = i+1 end
  until i==n or not data[1]
end

-- returns the fact related to the given fact id
function faces_methods:consult(fid)
  local fact = assert(self.fact_list[fid],
                      "Unable to find fact with index " .. tostring(fid))
  return fact
end

-- declares a new rule in the knowledge base
function faces_methods:defrule(rule_name)
  local rule = { patterns={}, user_clauses = {},
                 actions={}, salience=0, var_matches = {}, fact_vars = {} }
  self.kb_table[rule_name] = rule
  local rule_builder
  rule_builder = {
    pattern = function(rule_builder, pattern)
      table.insert(rule.patterns, tuple(pattern))
      return rule_builder
    end,
    var = function(rule_builder, varname)
      varname = assert(varname:match("%?([^%s]+)"),
                       string.format("Incorrect variable name: %s", varname))
      rule.fact_vars[varname] = #rule.patterns + 1
      return {
        pattern = function(_,...)
          return rule_builder.pattern(rule_builder,...)
        end,
      }
    end,
    u = function(rule_builder, ...)
      -- user_func receives one argument: vars
      table.insert(rule.user_clauses, get_user_func(...))
      return rule_builder
    end,
    salience = function(rule_builder, value)
      rule.salience = value
      return rule_builder
    end,
    match = function(rule_builder, varname, value)
      varname = assert(varname:match("%?([^%s]+)"),
                       string.format("Incorrect variable name: %s", varname))
      rule.var_matches[varname] = function(v)
        return v:find(value)
      end
      return rule_builder
    end,
    numeric = function(rule_builder, varname)
      varname = assert(varname:match("%?([^%s]+)"),
                       string.format("Incorrect variable name: %s", varname))
      rule.var_matches[varname] = function(v)
        return type(v) == "number"
      end
      return rule_builder
    end,
    ENTAILS = function(_, arg)
      assert(arg == "=>", "ENTAILS needs '=>' string as argument")
      update_forward_chaining_with_rule(self, rule_name, rule)
      return setmetatable({},{
          __index = function(rule_builder, key)
            if key == "u" then
              return function(rule_builder, ...)
                -- user_func receives one argument: vars
                table.insert(rule.actions, get_user_func(...))
                return rule_builder
              end
            else
              local f = assert(self[key], "Undefined function " .. key)
              if key == "fassert" then
                return function(rule_builder, ...)
                  local args = table.pack(...)
                  table.insert(rule.actions,
                               function(vars)
                                 local args = replace_user_functions(args, vars)
                                 for i=1,args.n do args[i] = tuple(args[i]) end
                                 local new_args = replace_variables(args, vars)
                                 return self[key](self, table.unpack(new_args))
                  end)
                  return rule_builder
                end
              elseif key == "retract" then
                return function(rule_builder, ...)
                  local args = table.pack(...)
                  table.insert(rule.actions,
                               function(vars)
                                 local args = replace_user_functions(args, vars)
                                 local new_args = replace_variables({ args }, vars)
                                 return self[key](self, table.unpack(new_args[1]))
                  end)
                  return rule_builder
                end
              else
                error("Key %s not available (it could be using user defined function")
              end
            end
          end
      })
    end
  }
  return rule_builder
end

-----------------
-- CONSTRUCTOR --
-----------------

--
local faces_metatable = {
  __index = faces_methods,
}

-- calling faces table returns a new rule-based expert system
setmetatable(faces, {
               __call = function()
                 local t = {
                   -- knowledge-base table, contains all the rules
                   kb_table = {},
                 }
                 local t = setmetatable(t, faces_metatable)
                 t:clear()
                 return t
               end
})

-- returns module table
return faces
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- init script embedded at compile time.  executed in
-- zen_load_extensions(L) usually after zen_init()

-- -- remap fatal and error
function fatal(msg)
	  if type(msg) == "string" then warn(trim(msg),2) end
	  debug.traceback()
--	  if ZEN_traceback ~= "" then ZEN:debug() end
	  ZEN:debug()
	  msg = msg or "fatal error"
	  error(msg,2)
end

-- global
_G["REQUIRED"] = { }
-- avoid duplicating requires (internal includes)
function require_once(ninc)
   local class = REQUIRED[ninc]
   if type(class) == "table" then return class end
   -- new require
   class = require(ninc)
   if type(class) == "table" then REQUIRED[ninc] = class end
   return class
end

-- error = zen_error -- from zen_io

-- ZEN = { assert = assert } -- zencode shim when not loaded
require('zenroom_common')
INSPECT = require('inspect')
OCTET  = require('zenroom_octet')
JSON   = require('zenroom_json')
CBOR   = require('zenroom_cbor')
ECDH   = require('zenroom_ecdh')
AES    = require('zenroom_aes')
BIG    = require('zenroom_big')
ECP    = require('zenroom_ecp')
ECP2   = require('zenroom_ecp2')
HASH   = require('zenroom_hash')
BENCH  = require('zenroom_bench')
MACHINE = require('statemachine')

O   = OCTET  -- alias
INT = BIG    -- alias
H   = HASH   -- alias
I   = INSPECT -- alias
PAIR = ECP2  -- alias
PAIR.ate = ECP2.miller --alias
V   = require('semver')
VERSION = V(VERSION)

ZEN = require('zencode')
-- requires zencode_ast

-- base zencode functions and schemas
require('zencode_data')
require('zencode_given')
require('zencode_when')
require('zencode_then')
require('zencode_eval')
if DEBUG > 0 then require('zencode_debug') end

-- scenario are loaded on-demand
-- scenarios can only implement "When ..." steps
_G["Given"] = nil
_G["Then"]  = nil

-----------
-- defaults
_G["CONF"] = {
   -- goldilocks is our favorite ECDH/DSA curve
   -- other choices here include secp256k1 or ed25519 or bls383
   -- beware this choice affects only the ECDH object
   -- and ECDH public keys cannot function as ECP
   -- because of IANA 7303
   verbosity = 1,
   input = { encoding = input_encoding('url64'),
			 format = get_format('json'),
			 tagged = false },
   output = { encoding = get_encoding('url64'),
			  format = get_format('json'),
			  versioning = false },
   parser = { strict_match = true },
   heapguard = true
}

-- encoding base64url (RFC4648) is the fastest and most portable in zenroom
-- set_encoding('url64')
-- set_format('json')

collectgarbage'collect'
--- <h1>Debug inspection facility</h1>
--
-- The INSPECT class provides a number of functions to ease
-- development and debugging. It mainly consists of an advanced
-- @{print} function that can represent complex data structures (Lua
-- tables) and tag their encoding formats and size.  Another @{spy}
-- function prints the same as pass-through.
--
-- @module INSPECT
-- @version inspect.lua 3.1.0
-- @author Kikito <a href="http://github.com/kikito/inspect.lua">github.com/kikito/inspect.lua</a>
-- @license MIT

local inspect ={
  _VERSION = 'inspect.lua 3.1.0',
  _URL     = 'http://github.com/kikito/inspect.lua',
  _DESCRIPTION = 'human-readable representations of tables'
  -- _LICENSE = [[
  --   MIT LICENSE

  --   Copyright (c) 2013 Enrique García Cota

  --   Permission is hereby granted, free of charge, to any person obtaining a
  --   copy of this software and associated documentation files (the
  --   "Software"), to deal in the Software without restriction, including
  --   without limitation the rights to use, copy, modify, merge, publish,
  --   distribute, sublicense, and/or sell copies of the Software, and to
  --   permit persons to whom the Software is furnished to do so, subject to
  --   the following conditions:

  --   The above copyright notice and this permission notice shall be included
  --   in all copies or substantial portions of the Software.

  --   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  --   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  --   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  --   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  --   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  --   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  --   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  -- ]]
}

local tostring = tostring

inspect.KEY       = setmetatable({}, {__tostring = function() return 'inspect.KEY' end})
inspect.METATABLE = setmetatable({}, {__tostring = function() return 'inspect.METATABLE' end})

-- Apostrophizes the string if it has quotes, but not aphostrophes
-- Otherwise, it returns a regular quoted string
local function smartQuote(str)
  if str:match('"') and not str:match("'") then
    return "'" .. str .. "'"
  end
  return '"' .. str:gsub('"', '\\"') .. '"'
end

-- \a => '\\a', \0 => '\\0', 31 => '\31'
local shortControlCharEscapes = {
  ["\a"] = "\\a",  ["\b"] = "\\b", ["\f"] = "\\f", ["\n"] = "\\n",
  ["\r"] = "\\r",  ["\t"] = "\\t", ["\v"] = "\\v"
}
local longControlCharEscapes = {} -- \a => nil, \0 => \000, 31 => \031
for i=0, 31 do
  local ch = string.char(i)
  if not shortControlCharEscapes[ch] then
    shortControlCharEscapes[ch] = "\\"..i
    longControlCharEscapes[ch]  = string.format("\\%03d", i)
  end
end

local function escape(str)
  return (str:gsub("\\", "\\\\")
             :gsub("(%c)%f[0-9]", longControlCharEscapes)
             :gsub("%c", shortControlCharEscapes))
end

local function isIdentifier(str)
  return type(str) == 'string' and str:match( "^[_%a][_%a%d]*$" )
end

local function isSequenceKey(k, sequenceLength)
  return type(k) == 'number'
     and 1 <= k
     and k <= sequenceLength
     and math.floor(k) == k
end

local defaultTypeOrders = {
  ['number']   = 1, ['boolean']  = 2, ['string'] = 3, ['table'] = 4,
  ['function'] = 5, ['userdata'] = 6, ['thread'] = 7
}

local function sortKeys(a, b)
  local ta, tb = type(a), type(b)

  -- strings and numbers are sorted numerically/alphabetically
  if ta == tb and (ta == 'string' or ta == 'number') then return a < b end

  local dta, dtb = defaultTypeOrders[ta], defaultTypeOrders[tb]
  -- Two default types are compared according to the defaultTypeOrders table
  if dta and dtb then return defaultTypeOrders[ta] < defaultTypeOrders[tb]
  elseif dta     then return true  -- default types before custom ones
  elseif dtb     then return false -- custom types after default ones
  end

  -- custom types are sorted out alphabetically
  return ta < tb
end

-- For implementation reasons, the behavior of rawlen & # is "undefined" when
-- tables aren't pure sequences. So we implement our own # operator.
local function getSequenceLength(t)
  local len = 1
  local v = rawget(t,len)
  while v ~= nil do
    len = len + 1
    v = rawget(t,len)
  end
  return len - 1
end

local function getNonSequentialKeys(t)
  local keys = {}
  local sequenceLength = getSequenceLength(t)
  for k,_ in pairs(t) do
    if not isSequenceKey(k, sequenceLength) then table.insert(keys, k) end
  end
  table.sort(keys, sortKeys)
  return keys, sequenceLength
end

local function getToStringResultSafely(t, mt)
  local __tostring = type(mt) == 'table' and rawget(mt, '__tostring')
  local str, ok
  if type(__tostring) == 'function' then
    ok, str = pcall(__tostring, t)
    str = ok and str or 'error: ' .. tostring(str)
  end
  if type(str) == 'string' and #str > 0 then return str end
end

local function countTableAppearances(t, tableAppearances)
  tableAppearances = tableAppearances or {}

  if type(t) == 'table' then
    if not tableAppearances[t] then
      tableAppearances[t] = 1
      for k,v in pairs(t) do
        countTableAppearances(k, tableAppearances)
        countTableAppearances(v, tableAppearances)
      end
      countTableAppearances(getmetatable(t), tableAppearances)
    else
      tableAppearances[t] = tableAppearances[t] + 1
    end
  end

  return tableAppearances
end

local copySequence = function(s)
  local copy, len = {}, #s
  for i=1, len do copy[i] = s[i] end
  return copy, len
end

local function makePath(path, ...)
  local keys = {...}
  local newPath, len = copySequence(path)
  for i=1, #keys do
    newPath[len + i] = keys[i]
  end
  return newPath
end

local function processRecursive(process, item, path, visited)
    if item == nil then return nil end
    if visited[item] then return visited[item] end

    local processed = process(item, path)

    if type(processed) == 'table' then
      local processedCopy = {}
      visited[item] = processedCopy
      local processedKey

      for k,v in pairs(processed) do
        processedKey = processRecursive(process, k, makePath(path, k, inspect.KEY), visited)

        if processedKey ~= nil then
          processedCopy[processedKey] = processRecursive(process, v, makePath(path, processedKey), visited)
        end
      end

      local mt  = processRecursive(process, getmetatable(processed), makePath(path, inspect.METATABLE), visited)
      if type(mt) ~= 'table' then mt = nil end -- ignore not nil/table __metatable field
      setmetatable(processedCopy, mt)
      processed = processedCopy
    end
    return processed
end



-------------------------------------------------------------------

local Inspector = {}
local Inspector_mt = {__index = Inspector}

function Inspector:puts(...)
  local args   = {...}
  local buffer = self.buffer
  local len    = #buffer
  for i=1, #args do
    len = len + 1
    buffer[len] = args[i]
  end
end

function Inspector:down(f)
  self.level = self.level + 1
  f()
  self.level = self.level - 1
end

function Inspector:tabify()
  self:puts(self.newline, string.rep(self.indent, self.level))
end

function Inspector:alreadyVisited(v)
  return self.ids[v] ~= nil
end

function Inspector:getId(v)
  local id = self.ids[v]
  if not id then
    local tv = type(v)
    id              = (self.maxIds[tv] or 0) + 1
    self.maxIds[tv] = id
    self.ids[v]     = id
  end
  return tostring(id)
end

function Inspector:putKey(k)
  if isIdentifier(k) then return self:puts(k) end
  self:puts("[")
  self:putValue(k)
  self:puts("]")
end

function Inspector:putTable(t)
  if t == inspect.KEY or t == inspect.METATABLE then
    self:puts(tostring(t))
  elseif self:alreadyVisited(t) then
    self:puts('<table ', self:getId(t), '>')
  elseif self.level >= self.depth then
    self:puts('{...}')
  else
    if self.tableAppearances[t] > 1 then self:puts('<', self:getId(t), '>') end

    local nonSequentialKeys, sequenceLength = getNonSequentialKeys(t)
    local mt                = getmetatable(t)
    local toStringResult    = getToStringResultSafely(t, mt)

    self:puts('{')
    self:down(function()
      if toStringResult then
        self:puts(' -- ', escape(toStringResult))
        if sequenceLength >= 1 then self:tabify() end
      end

      local count = 0
      for i=1, sequenceLength do
        if count > 0 then self:puts(',') end
        self:puts(' ')
        self:putValue(t[i])
        count = count + 1
      end

      for _,k in ipairs(nonSequentialKeys) do
        if count > 0 then self:puts(',') end
        self:tabify()
        self:putKey(k)
        self:puts(' = ')
        self:putValue(t[k])
        count = count + 1
      end

      if type(mt) == 'table' then
        if count > 0 then self:puts(',') end
        self:tabify()
        self:puts('<metatable> = ')
        self:putValue(mt)
      end
    end)

    if #nonSequentialKeys > 0 or type(mt) == 'table' then -- result is multi-lined. Justify closing }
      self:tabify()
    elseif sequenceLength > 0 then -- array tables have one extra space before closing }
      self:puts(' ')
    end

    self:puts('}')
  end
end

function Inspector:putValue(v)
  local tv = type(v)

  enc = CONF.encoding or url64
  if tv == 'string' then
    self:puts(smartQuote(escape(v)))
  elseif tv == 'number' or tv == 'boolean' or tv == 'nil' or
         tv == 'cdata' or tv == 'ctype' then
    self:puts(tostring(v))
  elseif tv == 'table' then
    self:putTable(v)
  elseif iszen(tv) then
	 if tv == "zenroom.octet" then
		self:puts("octet[" .. #v .. "] " .. ZEN:export(v))
	 elseif tv == "zenroom.big" then
		local i = v:octet()
		self:puts("int[" .. #i.. "] " .. ZEN:export(i))
	 elseif tv == "zenroom.ecp" then
		local i = v:octet()
		if v == "Infinity" or v == ECP.infinity() then
		   self:puts("ecp[...] (Infinity)")
		else
		   self:puts("ecp[" .. #i.. "] " .. ZEN:export(i))
		end
	 elseif tv == "zenroom.ecp2" then
		local i = v:octet()
		if v == "Infinity" or v == ECP2.infinity() then
		   self:puts("ecp[...] (Infinity)")
		else
		   self:puts("ecp2[" ..#i.. "] ".. ZEN:export(i))
		end
	 elseif tv == "zenroom.fp12" then
		local i = v:octet()
		self:puts("fp12[" ..#i.. "] ".. ZEN:export(i))
	 elseif tv == "zenroom.ecdh" then
		local pk = v:public()
		local sk = v:private()
		if not pk and not sk then self:puts("ecdh keyring is empty\n")
		else
		   if pk then self:puts("ecdh.public["..#pk.."] ".. ZEN:export(pk).."\n") end
		   if sk then self:puts("ecdh.private["..#sk.."] ".. ZEN:export(sk).."\n") end
		end
	 else
		self:puts(ZEN:export(v:octet()))
	 end
  else
    self:puts('<',tv,' ',self:getId(v),'>')
  end
end

-------------------------------------------------------------------

function inspect.inspect(root, options)
  options       = options or {}

  local depth   = options.depth   or math.huge
  local newline = options.newline or '\n'
  local indent  = options.indent  or '    '
  local process = options.process

  if process then
    root = processRecursive(process, root, {}, {})
  end

  local inspector = setmetatable({
    depth            = depth,
    level            = 0,
    buffer           = {},
    ids              = {},
    maxIds           = {},
    newline          = newline,
    indent           = indent,
    tableAppearances = countTableAppearances(root)
  }, Inspector_mt)

  inspector:putValue(root)

  return table.concat(inspector.buffer)
end

-- conversion wrappers for zenroom types
function inspect.encode(item)
   t = type(item)
   if iszen(t) then
	  return ZEN:export(item)
   -- elseif iszen(t) then
   -- 	  if t == "zenroom.ecp" and ECP.isinf(item) then
   -- 	  	 return "Infinity"
   -- 	  else
   -- 	  	 return ZEN:export(item)
   -- 	  end
   else
	  return item
   end
end

-- apply conversion wrapper to all values of a table
function inspect.process(item)
   return processRecursive(inspect.encode, item, {}, {})
end

--- Print all contents of a table in a tree representation, works with
-- complex data structures and prints to STDOUT.
--
-- @function INSPECT.print(object)
-- @param object complex table data structure
function inspect.print(root, options)
   print(inspect.inspect(root, options))
   return root
end

--- Print all contents of a table to STDERR. Works same way as @{print}.
--
-- @function INSPECT.warn(object)
-- @param object complex table data structure
function inspect.warn(root, options)
   warn(inspect.inspect(root, options))
   return root
end

--- Print all contents of a table to STDERR and return same object as
--- passthrough. Works same way as @{print}.
--
-- @function INSPECT.spy(object)
-- @param object complex table data structure
-- @return object itself (passthrough for nesting)
inspect.spy = inspect.warn

setmetatable(inspect, { __call = function(_, ...) return inspect.print(...) end })

return inspect

--
-- json.lua
--
-- Copyright (c) 2019 rxi
--
-- Permission is hereby granted, free of charge, to any person obtaining a copy of
-- this software and associated documentation files (the "Software"), to deal in
-- the Software without restriction, including without limitation the rights to
-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
-- of the Software, and to permit persons to whom the Software is furnished to do
-- so, subject to the following conditions:
--
-- The above copyright notice and this permission notice shall be included in all
-- copies or substantial portions of the Software.
--
-- THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
-- SOFTWARE.
--

local json = { _version = "0.1.2" }

-------------------------------------------------------------------------------
-- Encode
-------------------------------------------------------------------------------

local encode

local escape_char_map = {
  [ "\\" ] = "\\\\",
  [ "\"" ] = "\\\"",
  [ "\b" ] = "\\b",
  [ "\f" ] = "\\f",
  [ "\n" ] = "\\n",
  [ "\r" ] = "\\r",
  [ "\t" ] = "\\t",
}

local escape_char_map_inv = { [ "\\/" ] = "/" }
for k, v in pairs(escape_char_map) do
  escape_char_map_inv[v] = k
end


local function escape_char(c)
  return escape_char_map[c] or string.format("\\u%04x", c:byte())
end


local function encode_nil(val)
  return "null"
end


local function encode_table(val, stack)
  local res = {}
  stack = stack or {}

  -- Circular reference?
  if stack[val] then error("circular reference") end

  stack[val] = true

  if rawget(val, 1) ~= nil or next(val) == nil then
    -- Treat as array -- check keys are valid and it is not sparse
    local n = 0
    for k in pairs(val) do
      if type(k) ~= "number" then
        error("invalid table: mixed or invalid key types")
      end
      n = n + 1
    end
    if n ~= #val then
      error("invalid table: sparse array")
    end
    -- Encode
    for i, v in sort_ipairs(val) do
      table.insert(res, encode(v, stack))
    end
    stack[val] = nil
    return "[" .. table.concat(res, ",") .. "]"

  else
    -- Treat as an object
    for k, v in sort_pairs(val) do
      if type(k) ~= "string" then
        error("invalid table: mixed or invalid key types")
      end
      table.insert(res, encode(k, stack) .. ":" .. encode(v, stack))
    end
    stack[val] = nil
    return "{" .. table.concat(res, ",") .. "}"
  end
end


local function encode_string(val)
  return '"' .. val:gsub('[%z\1-\31\\"]', escape_char) .. '"'
end


local function encode_number(val)
  -- Check for NaN, -inf and inf
  if val ~= val or val <= -math.huge or val >= math.huge then
    error("unexpected number value '" .. tostring(val) .. "'")
  end
  return string.format("%.14g", val)
end

local function encode_function(val)
   -- return hex function address as string
   return '"' .. strtok(tostring(val))[2] .. '"'
end

local type_func_map = {
  [ "nil"     ] = encode_nil,
  [ "table"   ] = encode_table,
  [ "string"  ] = encode_string,
  [ "number"  ] = encode_number,
  [ "function"] = encode_function,
  [ "boolean" ] = tostring,
}


encode = function(val, stack)
  local t = type(val)
  local f = type_func_map[t]
  if f then
    return f(val, stack)
  end
  error("unexpected type '" .. t .. "'")
end


function json.raw_encode(val)
   return(encode(val))
   -- sort
   -- local out = "{ "
   -- for k,v in sort_pairs(val) do
   -- 	  out = out .. '"'..k..'": '
   -- 	  out = out .. encode(v)..","
   -- end
   -- return(out:sub(1,-2) .. "}")
end


-------------------------------------------------------------------------------
-- Decode
-------------------------------------------------------------------------------

local parse

local function create_set(...)
  local res = {}
  for i = 1, select("#", ...) do
    res[ select(i, ...) ] = true
  end
  return res
end

local space_chars   = create_set(" ", "\t", "\r", "\n")
local delim_chars   = create_set(" ", "\t", "\r", "\n", "]", "}", ",")
local escape_chars  = create_set("\\", "/", '"', "b", "f", "n", "r", "t", "u")
local literals      = create_set("true", "false", "null")

local literal_map = {
  [ "true"  ] = true,
  [ "false" ] = false,
  [ "null"  ] = nil,
}


local function next_char(str, idx, set, negate)
  for i = idx, #str do
    if set[str:sub(i, i)] ~= negate then
      return i
    end
  end
  return #str + 1
end


local function decode_error(str, idx, msg)
  local line_count = 1
  local col_count = 1
  for i = 1, idx - 1 do
    col_count = col_count + 1
    if str:sub(i, i) == "\n" then
      line_count = line_count + 1
      col_count = 1
    end
  end
  error( string.format("%s at line %d col %d", msg, line_count, col_count) )
end


local function codepoint_to_utf8(n)
  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi&id=iws-appendixa
  local f = math.floor
  if n <= 0x7f then
    return string.char(n)
  elseif n <= 0x7ff then
    return string.char(f(n / 64) + 192, n % 64 + 128)
  elseif n <= 0xffff then
    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)
  elseif n <= 0x10ffff then
    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,
                       f(n % 4096 / 64) + 128, n % 64 + 128)
  end
  error( string.format("invalid unicode codepoint '%x'", n) )
end


local function parse_unicode_escape(s)
  local n1 = tonumber( s:sub(3, 6),  16 )
  local n2 = tonumber( s:sub(9, 12), 16 )
  -- Surrogate pair?
  if n2 then
    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)
  else
    return codepoint_to_utf8(n1)
  end
end


local function parse_string(str, i)
  local has_unicode_escape = false
  local has_surrogate_escape = false
  local has_escape = false
  local last
  for j = i + 1, #str do
    local x = str:byte(j)

    if x < 32 then
      decode_error(str, j, "control character in string")
    end

    if last == 92 then -- "\\" (escape char)
      if x == 117 then -- "u" (unicode escape sequence)
        local hex = str:sub(j + 1, j + 5)
        if not hex:find("%x%x%x%x") then
          decode_error(str, j, "invalid unicode escape in string")
        end
        if hex:find("^[dD][89aAbB]") then
          has_surrogate_escape = true
        else
          has_unicode_escape = true
        end
      else
        local c = string.char(x)
        if not escape_chars[c] then
          decode_error(str, j, "invalid escape char '" .. c .. "' in string")
        end
        has_escape = true
      end
      last = nil

    elseif x == 34 then -- '"' (end of string)
      local s = str:sub(i + 1, j - 1)
      if has_surrogate_escape then
        s = s:gsub("\\u[dD][89aAbB]..\\u....", parse_unicode_escape)
      end
      if has_unicode_escape then
        s = s:gsub("\\u....", parse_unicode_escape)
      end
      if has_escape then
        s = s:gsub("\\.", escape_char_map_inv)
      end
      return s, j + 1

    else
      last = x
    end
  end
  decode_error(str, i, "expected closing quote for string")
end


local function parse_number(str, i)
  local x = next_char(str, i, delim_chars)
  local s = str:sub(i, x - 1)
  local n = tonumber(s)
  if not n then
    decode_error(str, i, "invalid number '" .. s .. "'")
  end
  return n, x
end


local function parse_literal(str, i)
  local x = next_char(str, i, delim_chars)
  local word = str:sub(i, x - 1)
  if not literals[word] then
    decode_error(str, i, "invalid literal '" .. word .. "'")
  end
  return literal_map[word], x
end


local function parse_array(str, i)
  local res = {}
  local n = 1
  i = i + 1
  while 1 do
    local x
    i = next_char(str, i, space_chars, true)
    -- Empty / end of array?
    if str:sub(i, i) == "]" then
      i = i + 1
      break
    end
    -- Read token
    x, i = parse(str, i)
    res[n] = x
    n = n + 1
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "]" then break end
    if chr ~= "," then decode_error(str, i, "expected ']' or ','") end
  end
  return res, i
end


local function parse_object(str, i)
  local res = {}
  i = i + 1
  while 1 do
    local key, val
    i = next_char(str, i, space_chars, true)
    -- Empty / end of object?
    if str:sub(i, i) == "}" then
      i = i + 1
      break
    end
    -- Read key
    if str:sub(i, i) ~= '"' then
      decode_error(str, i, "expected string for key")
    end
    key, i = parse(str, i)
    -- Read ':' delimiter
    i = next_char(str, i, space_chars, true)
    if str:sub(i, i) ~= ":" then
      decode_error(str, i, "expected ':' after key")
    end
    i = next_char(str, i + 1, space_chars, true)
    -- Read value
    val, i = parse(str, i)
    -- Set
    res[key] = val
    -- Next token
    i = next_char(str, i, space_chars, true)
    local chr = str:sub(i, i)
    i = i + 1
    if chr == "}" then break end
    if chr ~= "," then decode_error(str, i, "expected '}' or ','") end
  end
  return res, i
end


local char_func_map = {
  [ '"' ] = parse_string,
  [ "0" ] = parse_number,
  [ "1" ] = parse_number,
  [ "2" ] = parse_number,
  [ "3" ] = parse_number,
  [ "4" ] = parse_number,
  [ "5" ] = parse_number,
  [ "6" ] = parse_number,
  [ "7" ] = parse_number,
  [ "8" ] = parse_number,
  [ "9" ] = parse_number,
  [ "-" ] = parse_number,
  [ "t" ] = parse_literal,
  [ "f" ] = parse_literal,
  [ "n" ] = parse_literal,
  [ "[" ] = parse_array,
  [ "{" ] = parse_object,
}


parse = function(str, idx)
  local chr = str:sub(idx, idx)
  local f = char_func_map[chr]
  if f then
    return f(str, idx)
  end
  decode_error(str, idx, "unexpected character '" .. chr .. "'")
end


function json.raw_decode(str)
  if type(str) ~= "string" then
    error("expected argument of type string, got " .. type(str))
  end
  local res, idx = parse(str, next_char(str, 1, space_chars, true))
  idx = next_char(str, idx, space_chars, true)
  if idx <= #str then
    decode_error(str, idx, "trailing garbage")
  end
  return res
end


return json
local semver = {
   _VERSION     = '1.2.2',
   _DESCRIPTION = 'semver for Lua',
   _URL         = 'https://github.com/kikito/semver.lua'
  --  _LICENSE     = [[
  --   MIT LICENSE

  --   Copyright (c) 2015 Enrique García Cota
  --   Copyright (c) 2019 Dyne.org foundation

  --   Permission is hereby granted, free of charge, to any person obtaining a
  --   copy of tother software and associated documentation files (the
  --   "Software"), to deal in the Software without restriction, including
  --   without limitation the rights to use, copy, modify, merge, publish,
  --   distribute, sublicense, and/or sell copies of the Software, and to
  --   permit persons to whom the Software is furnished to do so, subject to
  --   the following conditions:

  --   The above copyright notice and tother permission notice shall be included
  --   in all copies or substantial portions of the Software.

  --   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  --   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  --   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
  --   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
  --   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
  --   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
  --   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  -- ]]
}

local function checkPositiveInteger(number, name)
   assert(number >= 0, name .. ' must be a valid positive number')
   assert(math.floor(number) == number, name .. ' must be an integer')
end

local function present(value)
   return value and value ~= ''
end

-- splitByDot("a.bbc.d") == {"a", "bbc", "d"}
local function splitByDot(str)
   str = str or ""
   local t, count = {}, 0
   str:gsub("([^%.]+)", function(c)
			   count = count + 1
			   t[count] = c
   end)
   return t
end

local function parsePrereleaseAndBuildWithSign(str)
   local prereleaseWithSign, buildWithSign = str:match("^(-[^+]+)(+.+)$")
   if not (prereleaseWithSign and buildWithSign) then
	  prereleaseWithSign = str:match("^(-.+)$")
	  buildWithSign      = str:match("^(+.+)$")
   end
   assert(prereleaseWithSign or buildWithSign, ("The parameter %q must begin with + or - to denote a prerelease or a build"):format(str))
   return prereleaseWithSign, buildWithSign
end

local function parsePrerelease(prereleaseWithSign)
   if prereleaseWithSign then
	  local prerelease = prereleaseWithSign:match("^-(%w[%.%w-]*)$")
	  assert(prerelease, ("The prerelease %q is not a slash followed by alphanumerics, dots and slashes"):format(prereleaseWithSign))
	  return prerelease
   end
end

local function parseBuild(buildWithSign)
   if buildWithSign then
	  local build = buildWithSign:match("^%+(%w[%.%w-]*)$")
	  assert(build, ("The build %q is not a + sign followed by alphanumerics, dots and slashes"):format(buildWithSign))
	  return build
   end
end

local function parsePrereleaseAndBuild(str)
   if not present(str) then return nil, nil end

   local prereleaseWithSign, buildWithSign = parsePrereleaseAndBuildWithSign(str)

   local prerelease = parsePrerelease(prereleaseWithSign)
   local build = parseBuild(buildWithSign)

   return prerelease, build
end

local function parseVersion(str)
   local sMajor, sMinor, sPatch, sPrereleaseAndBuild = str:match("^(%d+)%.?(%d*)%.?(%d*)(.-)$")
   assert(type(sMajor) == 'string', ("Could not extract version number(s) from %q"):format(str))
   local major, minor, patch = tonumber(sMajor), tonumber(sMinor), tonumber(sPatch)
   local prerelease, build = parsePrereleaseAndBuild(sPrereleaseAndBuild)
   return major, minor, patch, prerelease, build
end


-- return 0 if a == b, -1 if a < b, and 1 if a > b
local function compare(a,b)
   return a == b and 0 or a < b and -1 or 1
end

local function compareIds(myId, otherId)
   if myId == otherId then return  0
   elseif not myId    then return -1
   elseif not otherId then return  1
   end

   local selfNumber, otherNumber = tonumber(myId), tonumber(otherId)

   if selfNumber and otherNumber then -- numerical comparison
	  return compare(selfNumber, otherNumber)
	  -- numericals are always smaller than alphanums
   elseif selfNumber then
	  return -1
   elseif otherNumber then
	  return 1
   else
	  return compare(myId, otherId) -- alphanumerical comparison
   end
end

local function smallerIdList(myIds, otherIds)
   local myLength = #myIds
   local comparison

   for i=1, myLength do
	  comparison = compareIds(myIds[i], otherIds[i])
	  if comparison ~= 0 then
		 return comparison == -1
	  end
	  -- if comparison == 0, continue loop
   end

   return myLength < #otherIds
end

local function smallerPrerelease(mine, other)
   if mine == other or not mine then return false
   elseif not other then return true
   end

   return smallerIdList(splitByDot(mine), splitByDot(other))
end

local methods = {}

function methods:nextMajor()
   return semver(self.major + 1, 0, 0)
end
function methods:nextMinor()
   return semver(self.major, self.minor + 1, 0)
end
function methods:nextPatch()
   return semver(self.major, self.minor, self.patch + 1)
end

local mt = { __index = methods }
function mt:__eq(other)
   return self.major == other.major and
	  self.minor == other.minor and
	  self.patch == other.patch and
	  self.prerelease == other.prerelease
   -- notice that build is ignored for precedence in semver 2.0.0
end
function mt:__lt(other)
   if self.major ~= other.major then return self.major < other.major end
   if self.minor ~= other.minor then return self.minor < other.minor end
   if self.patch ~= other.patch then return self.patch < other.patch end
   return smallerPrerelease(self.prerelease, other.prerelease)
   -- notice that build is ignored for precedence in semver 2.0.0
end
-- This works like the "pessimisstic operator" in Rubygems.
-- if a and b are versions, a ^ b means "b is backwards-compatible with a"
-- in other words, "it's safe to upgrade from a to b"
function mt:__pow(other)
   if self.major == 0 then
	  return self == other
   end
   return self.major == other.major and
	  self.minor <= other.minor
end

local function new(major, minor, patch, prerelease, build)
   assert(major, "At least one parameter is needed")
   local result = { }
   if type(major) == 'string' then
	  result.original = major
	  major,minor,patch,prerelease,build = parseVersion(major)
   end
   patch = patch or 0
   minor = minor or 0

   checkPositiveInteger(major, "major")
   checkPositiveInteger(minor, "minor")
   checkPositiveInteger(patch, "patch")

   result.major = major
   result.minor = minor
   result.patch = patch
   result.prerelease = prerelease
   result.build = build
   return setmetatable(result, mt)
end

setmetatable(semver, { __call = function(_, ...) return new(...) end })
semver._VERSION= semver(semver._VERSION)

return semver
-- Optional parser that creates a flat DOM from parsing
local SLAXML = require 'slaxml'
function SLAXML:dom(xml,opts)
	if not opts then opts={} end
	local rich = not opts.simple
	local push, pop = table.insert, table.remove
	local doc = {type="document", name="#doc", kids={}}
	local current,stack = doc, {doc}
	local builder = SLAXML:parser{
		startElement = function(name,nsURI,nsPrefix)
			local el = { type="element", name=name, kids={}, el=rich and {} or nil, attr={}, nsURI=nsURI, nsPrefix=nsPrefix, parent=rich and current or nil }
			if current==doc then
				if doc.root then error(("Encountered element '%s' when the document already has a root '%s' element"):format(name,doc.root.name)) end
				doc.root = rich and el or nil
			end
			push(current.kids,el)
			if current.el then push(current.el,el) end
			current = el
			push(stack,el)
		end,
		attribute = function(name,value,nsURI,nsPrefix)
			if not current or current.type~="element" then error(("Encountered an attribute %s=%s but I wasn't inside an element"):format(name,value)) end
			local attr = {type='attribute',name=name,nsURI=nsURI,nsPrefix=nsPrefix,value=value,parent=rich and current or nil}
			if rich then current.attr[name] = value end
			push(current.attr,attr)
		end,
		closeElement = function(name)
			if current.name~=name or current.type~="element" then error(("Received a close element notification for '%s' but was inside a '%s' %s"):format(name,current.name,current.type)) end
			pop(stack)
			current = stack[#stack]
		end,
		text = function(value,cdata)
			-- documents may only have text node children that are whitespace: https://www.w3.org/TR/xml/#NT-Misc
			if current.type=='document' and not value:find('^%s+$') then error(("Document has non-whitespace text at root: '%s'"):format(value:gsub('[\r\n\t]',{['\r']='\\r', ['\n']='\\n', ['\t']='\\t'}))) end
			push(current.kids,{type='text',name='#text',cdata=cdata and true or nil,value=value,parent=rich and current or nil})
		end,
		comment = function(value)
			push(current.kids,{type='comment',name='#comment',value=value,parent=rich and current or nil})
		end,
		pi = function(name,value)
			push(current.kids,{type='pi',name=name,value=value,parent=rich and current or nil})
		end
	}
	builder:parse(xml,opts)
	return doc
end

local escmap = {["<"]="&lt;", [">"]="&gt;", ["&"]="&amp;", ['"']="&quot;", ["'"]="&apos;"}
local function esc(s) return s:gsub('[<>&"]', escmap) end

-- opts.indent: number of spaces, or string
function SLAXML:xml(n,opts)
	opts = opts or {}
	local out = {}
	local tab = opts.indent and (type(opts.indent)=="number" and string.rep(" ",opts.indent) or opts.indent) or ""
	local ser = {}
	local omit = {}
	if opts.omit then for _,s in ipairs(opts.omit) do omit[s]=true end end

	function ser.document(n)
		for _,kid in ipairs(n.kids) do
			if ser[kid.type] then ser[kid.type](kid,0) end
		end
	end

	function ser.pi(n,depth)
		depth = depth or 0
		table.insert(out, tab:rep(depth)..'<?'..n.name..' '..n.value..'?>')
	end

	function ser.element(n,depth)
		if n.nsURI and omit[n.nsURI] then return end
		depth = depth or 0
		local indent = tab:rep(depth)
		local name = n.nsPrefix and n.nsPrefix..':'..n.name or n.name
		local result = indent..'<'..name
		if n.attr and n.attr[1] then
			local sorted = n.attr
			if opts.sort then
				sorted = {}
				for i,a in ipairs(n.attr) do sorted[i]=a end
				table.sort(sorted,function(a,b)
					if a.nsPrefix and b.nsPrefix then
						return a.nsPrefix==b.nsPrefix and a.name<b.name or a.nsPrefix<b.nsPrefix
					elseif not (a.nsPrefix or b.nsPrefix) then
						return a.name<b.name
					elseif b.nsPrefix then
						return true
					else
						return false
					end
				end)
			end

			local attrs = {}
			for _,a in ipairs(sorted) do
				if (not a.nsURI or not omit[a.nsURI]) and not (omit[a.value] and a.name:find('^xmlns:')) then
					attrs[#attrs+1] = ' '..(a.nsPrefix and (a.nsPrefix..':') or '')..a.name..'="'..esc(a.value)..'"'
				end
			end
			result = result..table.concat(attrs,'')
		end
		result = result .. (n.kids and n.kids[1] and '>' or '/>')
		table.insert(out, result)
		if n.kids and n.kids[1] then
			for _,kid in ipairs(n.kids) do
				if ser[kid.type] then ser[kid.type](kid,depth+1) end
			end
			table.insert(out, indent..'</'..name..'>')
		end
	end

	function ser.text(n,depth)
		if n.cdata then
			table.insert(out, tab:rep(depth)..'<![CDATA['..n.value..']]>')
		else
			table.insert(out, tab:rep(depth)..esc(n.value))
		end
	end

	function ser.comment(n,depth)
		table.insert(out, tab:rep(depth)..'<!--'..n.value..'-->')
	end

	ser[n.type](n,0)

	return table.concat(out, opts.indent and '\n' or '')
end

return SLAXML
--[=====================================================================[
v0.8 Copyright © 2013-2018 Gavin Kistner <!@phrogz.net>; MIT Licensed
See http://github.com/Phrogz/SLAXML for details.
--]=====================================================================]
local SLAXML = {
	VERSION = "0.8",
	_call = {
		pi = function(target,content)
			print(string.format("<?%s %s?>",target,content))
		end,
		comment = function(content)
			print(string.format("<!-- %s -->",content))
		end,
		startElement = function(name,nsURI,nsPrefix)
			                 io.write("<")
			if nsPrefix then io.write(nsPrefix,":") end
			                 io.write(name)
			if nsURI    then io.write(" (ns='",nsURI,"')") end
			                 print(">")
		end,
		attribute = function(name,value,nsURI,nsPrefix)
			                 io.write('  ')
			if nsPrefix then io.write(nsPrefix,":") end
			                 io.write(name,'=',string.format('%q',value))
			if nsURI    then io.write(" (ns='",nsURI,"')") end
			                 io.write("\n")
		end,
		text = function(text,cdata)
			print(string.format("  %s: %q",cdata and 'cdata' or 'text',text))
		end,
		closeElement = function(name,nsURI,nsPrefix)
			                 io.write("</")
			if nsPrefix then io.write(nsPrefix,":") end
			                 print(name..">")
		end,
	}
}

function SLAXML:parser(callbacks)
	return { _call=callbacks or self._call, parse=SLAXML.parse }
end

function SLAXML:parse(xml,options)
	if not options then options = { stripWhitespace=false } end

	-- Cache references for maximum speed
	local find, sub, gsub, char, push, pop, concat = string.find, string.sub, string.gsub, string.char, table.insert, table.remove, table.concat
	local first, last, match1, match2, match3, pos2, nsURI
	local unpack = unpack or table.unpack
	local pos = 1
	local state = "text"
	local textStart = 1
	local currentElement={}
	local currentAttributes={}
	local currentAttributeCt -- manually track length since the table is re-used
	local nsStack = {}
	local anyElement = false

	local utf8markers = { {0x7FF,192}, {0xFFFF,224}, {0x1FFFFF,240} }
	local function utf8(decimal) -- convert unicode code point to utf-8 encoded character string
		if decimal<128 then return char(decimal) end
		local charbytes = {}
		for bytes,vals in ipairs(utf8markers) do
			if decimal<=vals[1] then
				for b=bytes+1,2,-1 do
					local mod = decimal%64
					decimal = (decimal-mod)/64
					charbytes[b] = char(128+mod)
				end
				charbytes[1] = char(vals[2]+decimal)
				return concat(charbytes)
			end
		end
	end
	local entityMap  = { ["lt"]="<", ["gt"]=">", ["amp"]="&", ["quot"]='"', ["apos"]="'" }
	local entitySwap = function(orig,n,s) return entityMap[s] or n=="#" and utf8(tonumber('0'..s)) or orig end
	local function unescape(str) return gsub( str, '(&(#?)([%d%a]+);)', entitySwap ) end

	local function finishText()
		if first>textStart and self._call.text then
			local text = sub(xml,textStart,first-1)
			if options.stripWhitespace then
				text = gsub(text,'^%s+','')
				text = gsub(text,'%s+$','')
				if #text==0 then text=nil end
			end
			if text then self._call.text(unescape(text),false) end
		end
	end

	local function findPI()
		first, last, match1, match2 = find( xml, '^<%?([:%a_][:%w_.-]*) ?(.-)%?>', pos )
		if first then
			finishText()
			if self._call.pi then self._call.pi(match1,match2) end
			pos = last+1
			textStart = pos
			return true
		end
	end

	local function findComment()
		first, last, match1 = find( xml, '^<!%-%-(.-)%-%->', pos )
		if first then
			finishText()
			if self._call.comment then self._call.comment(match1) end
			pos = last+1
			textStart = pos
			return true
		end
	end

	local function nsForPrefix(prefix)
		if prefix=='xml' then return 'http://www.w3.org/XML/1998/namespace' end -- http://www.w3.org/TR/xml-names/#ns-decl
		for i=#nsStack,1,-1 do if nsStack[i][prefix] then return nsStack[i][prefix] end end
		error(("Cannot find namespace for prefix %s"):format(prefix))
	end

	local function startElement()
		anyElement = true
		first, last, match1 = find( xml, '^<([%a_][%w_.-]*)', pos )
		if first then
			currentElement[2] = nil -- reset the nsURI, since this table is re-used
			currentElement[3] = nil -- reset the nsPrefix, since this table is re-used
			finishText()
			pos = last+1
			first,last,match2 = find(xml, '^:([%a_][%w_.-]*)', pos )
			if first then
				currentElement[1] = match2
				currentElement[3] = match1 -- Save the prefix for later resolution
				match1 = match2
				pos = last+1
			else
				currentElement[1] = match1
				for i=#nsStack,1,-1 do if nsStack[i]['!'] then currentElement[2] = nsStack[i]['!']; break end end
			end
			currentAttributeCt = 0
			push(nsStack,{})
			return true
		end
	end

	local function findAttribute()
		first, last, match1 = find( xml, '^%s+([:%a_][:%w_.-]*)%s*=%s*', pos )
		if first then
			pos2 = last+1
			first, last, match2 = find( xml, '^"([^<"]*)"', pos2 ) -- FIXME: disallow non-entity ampersands
			if first then
				pos = last+1
				match2 = unescape(match2)
			else
				first, last, match2 = find( xml, "^'([^<']*)'", pos2 ) -- FIXME: disallow non-entity ampersands
				if first then
					pos = last+1
					match2 = unescape(match2)
				end
			end
		end
		if match1 and match2 then
			local currentAttribute = {match1,match2}
			local prefix,name = string.match(match1,'^([^:]+):([^:]+)$')
			if prefix then
				if prefix=='xmlns' then
					nsStack[#nsStack][name] = match2
				else
					currentAttribute[1] = name
					currentAttribute[4] = prefix
				end
			else
				if match1=='xmlns' then
					nsStack[#nsStack]['!'] = match2
					currentElement[2]      = match2
				end
			end
			currentAttributeCt = currentAttributeCt + 1
			currentAttributes[currentAttributeCt] = currentAttribute
			return true
		end
	end

	local function findCDATA()
		first, last, match1 = find( xml, '^<!%[CDATA%[(.-)%]%]>', pos )
		if first then
			finishText()
			if self._call.text then self._call.text(match1,true) end
			pos = last+1
			textStart = pos
			return true
		end
	end

	local function closeElement()
		first, last, match1 = find( xml, '^%s*(/?)>', pos )
		if first then
			state = "text"
			pos = last+1
			textStart = pos

			-- Resolve namespace prefixes AFTER all new/redefined prefixes have been parsed
			if currentElement[3] then currentElement[2] = nsForPrefix(currentElement[3])    end
			if self._call.startElement then self._call.startElement(unpack(currentElement)) end
			if self._call.attribute then
				for i=1,currentAttributeCt do
					if currentAttributes[i][4] then currentAttributes[i][3] = nsForPrefix(currentAttributes[i][4]) end
					self._call.attribute(unpack(currentAttributes[i]))
				end
			end

			if match1=="/" then
				pop(nsStack)
				if self._call.closeElement then self._call.closeElement(unpack(currentElement)) end
			end
			return true
		end
	end

	local function findElementClose()
		first, last, match1, match2 = find( xml, '^</([%a_][%w_.-]*)%s*>', pos )
		if first then
			nsURI = nil
			for i=#nsStack,1,-1 do if nsStack[i]['!'] then nsURI = nsStack[i]['!']; break end end
		else
			first, last, match2, match1 = find( xml, '^</([%a_][%w_.-]*):([%a_][%w_.-]*)%s*>', pos )
			if first then nsURI = nsForPrefix(match2) end
		end
		if first then
			finishText()
			if self._call.closeElement then self._call.closeElement(match1,nsURI) end
			pos = last+1
			textStart = pos
			pop(nsStack)
			return true
		end
	end

	while pos<#xml do
		if state=="text" then
			if not (findPI() or findComment() or findCDATA() or findElementClose()) then
				if startElement() then
					state = "attributes"
				else
					first, last = find( xml, '^[^<]+', pos )
					pos = (first and last or pos) + 1
				end
			end
		elseif state=="attributes" then
			if not findAttribute() then
				if not closeElement() then
					error("Was in an element and couldn't find attributes or the close.")
				end
			end
		end
	end

	if not anyElement then error("Parsing did not discover any elements") end
	if #nsStack > 0 then error("Parsing ended with unclosed elements") end
end

return SLAXML
local machine = {}
machine.__index = machine

local NONE = "none"
local ASYNC = "async"

local function call_handler(handler, params)
  if handler then
    return handler(table.unpack(params))
  end
end

local function create_transition(name)
  local can, to, from, params

  local function transition(self, ...)
    if self.asyncState == NONE then
      can, to = self:can(name)
      from = self.current
      params = { self, name, from, to, ...}

      if not can then return false end
      self.currentTransitioningEvent = name

      local beforeReturn = call_handler(self["onbefore" .. name], params)
      local leaveReturn = call_handler(self["onleave" .. from], params)

      if beforeReturn == false or leaveReturn == false then
        return false
      end

      self.asyncState = name .. "WaitingOnLeave"

      if leaveReturn ~= ASYNC then
        transition(self, ...)
      end
      
      return true
    elseif self.asyncState == name .. "WaitingOnLeave" then
      self.current = to

      local enterReturn = call_handler(self["onenter" .. to] or self["on" .. to], params)

      self.asyncState = name .. "WaitingOnEnter"

      if enterReturn ~= ASYNC then
        transition(self, ...)
      end
      
      return true
    elseif self.asyncState == name .. "WaitingOnEnter" then
      call_handler(self["onafter" .. name] or self["on" .. name], params)
      call_handler(self["onstatechange"], params)
      self.asyncState = NONE
      self.currentTransitioningEvent = nil
      return true
    else
    	if string.find(self.asyncState, "WaitingOnLeave") or string.find(self.asyncState, "WaitingOnEnter") then
    		self.asyncState = NONE
    		transition(self, ...)
    		return true
    	end
    end

    self.currentTransitioningEvent = nil
    return false
  end

  return transition
end

local function add_to_map(map, event)
  if type(event.from) == 'string' then
    map[event.from] = event.to
  else
    for _, from in ipairs(event.from) do
      map[from] = event.to
    end
  end
end

function machine.create(options)
  assert(options.events)

  local fsm = {}
  setmetatable(fsm, machine)

  fsm.options = options
  fsm.current = options.initial or 'none'
  fsm.asyncState = NONE
  fsm.events = {}

  for _, event in ipairs(options.events or {}) do
    local name = event.name
    fsm[name] = fsm[name] or create_transition(name)
    fsm.events[name] = fsm.events[name] or { map = {} }
    add_to_map(fsm.events[name].map, event)
  end
  
  for name, callback in pairs(options.callbacks or {}) do
    fsm[name] = callback
  end

  return fsm
end

function machine:is(state)
  return self.current == state
end

function machine:can(e)
  local event = self.events[e]
  local to = event and event.map[self.current] or event.map['*']
  return to ~= nil, to
end

function machine:cannot(e)
  return not self:can(e)
end

function machine:todot(filename)
  local dotfile = io.open(filename,'w')
  dotfile:write('digraph {\n')
  local transition = function(event,from,to)
    dotfile:write(string.format('%s -> %s [label=%s];\n',from,to,event))
  end
  for _, event in pairs(self.options.events) do
    if type(event.from) == 'table' then
      for _, from in ipairs(event.from) do
        transition(event.name,from,event.to)
      end
    else
      transition(event.name,event.from,event.to)
    end
  end
  dotfile:write('}\n')
  dotfile:close()
end

function machine:transition(event)
  if self.currentTransitioningEvent == event then
    return self[self.currentTransitioningEvent](self)
  end
end

function machine:cancelTransition(event)
  if self.currentTransitioningEvent == event then
    self.asyncState = NONE
    self.currentTransitioningEvent = nil
  end
end

machine.NONE = NONE
machine.ASYNC = ASYNC

return machine
--[[
Copyright (c) 2010 Scott Vokes <vokes.s@gmail.com>
 
Permission is hereby granted, free of charge, to any person
obtaining a copy of this software and associated documentation
files (the "Software"), to deal in the Software without
restriction, including without limitation the rights to use,
copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the
Software is furnished to do so, subject to the following
conditions:
 
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
 
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.
--]]


-- Depenedencies
local assert, getmetatable, ipairs, pairs, pcall, setmetatable, type =
   assert, getmetatable, ipairs, pairs, pcall, setmetatable, type
local concat, insert, sort = table.concat, table.insert, table.sort
local strmatch, tostring = string.match, tostring

local function trace(...) print(string.format(...)) end

local function sentinel(descr)
   return setmetatable({}, { __tostring=function() return descr end })
end

local VAR, NIL = sentinel("[var]"), sentinel("[nil]")
local function is_var(t) return getmetatable(t) == VAR end

local tamale = { }

---Mark a string in a match pattern as a variable key.
-- (You probably want to alias this locally to something short.)
-- Any variables beginning with _ are ignored.
-- @usage { "extract", {var"_", var"_", var"third", var"_" } }
-- @usage A variable named "..." captures subsequent array-portion values.
tamale.var = function(name)
   assert(type(name) == "string", "Variable name must be string")
   local ignore = (name:sub(1, 1) == "_")
   local rest = (name == "...")
   return setmetatable( { name=name, ignore=ignore, rest=rest }, VAR)
end


---Returns a function that tests a string with string:match, rather
-- than ==. Any captures from the string match are appended to the
-- capture table. Like var, this would probably be locally aliased,
-- and used like { P"num (%d+)", handler }.
tamale.P = function(str)
   return function(v)
             if type(v) == "string" then return strmatch(v, str) end
          end
end


---Default hook for match failure.
-- @param val The unmatched value.
tamale.match_fail = function(val)
   return nil, "Match failed", val
end


-- Key-weak cache for table counts, since #t only gives the
-- length of the array portion, and otherwise, values with extra
-- non-numeric keys can match rows that do not have them.
local counts = setmetatable({}, { __mode="k"})

local function get_count(t)
   local v = counts[t]
   if not v then
      v = 0
      for k in pairs(t) do v = v + 1 end
      counts[t] = v
   end
   return v
end


-- Structurally match val against a pattern, setting variables in the
-- pattern to the corresponding values in val, and recursively
-- unifying table fields. Functions are treated as predicates - any
-- non-false result(s) are considered a success and are captured.
local function unify(pat, val, cs, ids, row)
   local pt, vt, nil_captures = type(pat), type(val), 0
   if pt == "table" then
      if is_var(pat) then
         local cur = cs[pat.name]
         if cur and cur ~= val and not pat.ignore then return false end
         cs[pat.name] = val
         return cs
      end
      if vt ~= "table" then return false end
      if ids[pat] and pat ~= val then --compare by pointer equality
         return false
      else
         for k,v in pairs(pat) do
            if not unify(v, val[k], cs, ids, row) then return false end
         end
      end
      if not row.partial then  --make sure val doesn't have extra fields
         if get_count(pat) ~= get_count(val) then return false end
      elseif row.rest then      --save V"..." captures
         local rest = {}
         for i=row.rest,#val do rest[#rest+1] = val[i] end
         cs['...'] = rest
      end
      return cs
   elseif pt == "function" then
      local fcs = { pat(val) }  --function captures
      if #fcs == 0 or not fcs[1] then return false end
      for _,c in ipairs(fcs) do cs[#cs+1] = c end
      return cs
   else                         --just compare as literals
      return pat == val and cs or false
   end
end


-- Replace any variables in the result with their captures.
local function substituted(res, u)
   local r = {}
   if is_var(res) then return u[res.name] end
   for k,v in pairs(res) do
      if type(v) == "table" then
         if is_var(v) then r[k] = u[v.name] else r[k] = substituted(v, u) end
      else
         r[k] = v
      end
   end
   return r
end


-- Return (or execute) the result, substituting any vars present.
local function do_res(res, u, has_vars)
   local t = type(res)
   if t == "function" then
      return res(u)
   elseif t == "table" and has_vars then
      return substituted(res, u), u
   end
   return res, u
end


local function append(t, key, val)
   local arr = t[key] or {}
   arr[#arr+1] = val; t[key] = arr
end


local function has_vars(res)
   if type(res) ~= "table" then return false end
   if is_var(res) then return true end
   for k,v in pairs(res) do
      if type(v) == "table" then
         if is_var(v) or has_vars(v) then return true end
      end
   end
   return false
end


-- If the list of row IDs didn't exist when the var row was
-- indexed (and thus didn't get added), add it here.
local function prepend_vars(vars, lists)
   for i=#vars,1,-1 do
      local vid = vars[i]
      for k,l in pairs(lists) do
         if l[1] > vid then insert(l, 1, vid) end
      end
   end
end

local function indexable(v)
   return not is_var(v) and type(v) ~= "function"
end

-- Index each literal pattern and pattern table's first value (t[1]). 
-- Also, add insert patterns with variables or functions in the
-- appropriate place(s).
local function index_spec(spec)
   local ls, ts = {}, {}        --literals and tables
   local lni, tni = {}, {}      --non-indexable fields for same
   local vrs = {}               --rows with vars in the result

   local debug = spec.debug
   -- field/value to index by, defaults to t[1].
   local ispec, indexer
   if spec.index == false then
      ispec = false   -- false -> don't index
   else
      ispec = spec.index or 1
   end

   if type(ispec) == "function" then indexer = ispec
   elseif ispec == "false" then
      indexer = function() end  --put everything in the same index
   else
      indexer = function(t) return t[ispec] end
   end
   spec.indexer = indexer

   for id, row in ipairs(spec) do
      local pat, res = row[1], row[2]
      local pt = type(pat)
      if not indexable(pat) then     --could match anything
         if debug then trace(" * rule %d: not indexable, adding to all", id) end
         lni[#lni+1] = id; tni[#tni+1] = id --for those that don't yet exist
         for _,l in ipairs{ls, ts} do       --and append to those that do
            for k in pairs(l) do append(l, k, id) end
         end
      elseif pt == "table" then
         local v = indexer(pat) or NIL
         if not indexable(v) then    --goes in every index
            if debug then trace(" * rule %d: index(table) is not indexable", id) end
            for k in pairs(ts) do append(ts, k, id) end
            tni[#tni+1] = id
         else
            if debug then trace(" * rule %d: indexing on index(t)=%s",
                                id, tostring(v)) end
            append(ts, v, id)
         end

         for i,v in ipairs(pat) do --check for special V"..." var
            if is_var(v) and v.rest then
               if debug then trace(" * rule %d: V'...' found in field %d",
                                   id, i) end
               row.partial = true; row.rest = i; break
            end
         end
      else
         if debug then trace(" * rule %d: indexing on %s",
                             id, tostring(pat)) end
         append(ls, pat, id)
      end
      if has_vars(res) then
         if debug then trace(" * rule %d: found var(s) in result", id) end
         vrs[id] = true
      end
   end

   prepend_vars(lni, ls)
   prepend_vars(tni, ts)
   ls[VAR] = lni; ts[VAR] = tni
   return { ls=ls, ts=ts, vrs=vrs }
end


-- Get the appropriate list of rows to check (if any).
local function check_index(spec, t, idx)
   local tt = type(t)
   if tt == "table" then
      local key = spec.indexer(t) or NIL
      local ts = idx.ts
      return ts[key] or ts[VAR]
   else
      local ls = idx.ls
      return ls[t] or ls[VAR]
   end
end


---Return a matcher function for a given specification. When the
-- function is called on one or more values, its first argument is
-- tested in order against every rule that could possibly match it,
-- selecting the relevant result (if any) or returning the values
-- (false, "Match failed", val).
-- If the result is a function, it is called with a table containing
-- any captures and any subsequent arguments passed to the matcher
-- function (in captures.args).
--@param spec A list of rows, where each row is of the form
--  { rule, result, [when=capture_predicate] }.
--@usage spec.ids: An optional list of table values that should be
--  compared by identity, not structure. If any empty tables are
--  being used as a sentinel value (e.g. "MAGIC_ID = {}"), list
--  them here.
--@usage spec.debug=true: Turn on debugging traces for the matcher.
tamale.matcher = function(spec)
   local debug = spec.debug or DEBUG
   local ids = {}
   if spec.ids then
      for _,id in ipairs(spec.ids) do ids[id] = true end
   end

   local idx = index_spec(spec)
   local vrs = idx.vrs  --variable rows

   return
   function (t, ...)
      local rows = check_index(spec, t, idx)
      if debug then
         trace(" -- Checking rules: %s", concat(rows, ", "))
      end

      for _,id in ipairs(rows) do
         local row = spec[id]
         local pat, res, when = row[1], row[2], row.when
         if debug and res == nil then trace " -- Missing result" end
         local args = { ... }

         local u = unify(pat, t, { args=args }, ids, row)
         if debug then
            trace(" -- Trying rule %d...%s", id, u and "matched" or "failed")
         end
         
         if u then
            u.input = t         --whole matched value
            if when then
               local ok, val = pcall(when, u)
               if debug then trace(" -- Running when(captures) check...%s",
                                   (ok and val) and "matched" or "failed")
               end
               if ok and val then
                  return do_res(res, u, vrs[id])
               end
            else
               return do_res(res, u, vrs[id])
            end
         end
      end
      if debug then trace(" -- Failed") end
      local fail = spec.fail or match_fail
      return fail(t)
   end         
end

return tamale
--[[
  This file is part of Lua-FaCES (https://github.com/pakozm/lua-faces)
  This file is part of Lua-Tuple (https://github.com/pakozm/lua-tuple)
  This file is part of Lua-MapReduce (https://github.com/pakozm/lua-mapreduce)
  
  Copyright 2014, Francisco Zamora-Martinez
  
  Permission is hereby granted, free of charge, to any person obtaining a copy
  of this software and associated documentation files (the "Software"), to deal
  in the Software without restriction, including without limitation the rights
  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  copies of the Software, and to permit persons to whom the Software is
  furnished to do so, subject to the following conditions:
  
  The above copyright notice and this permission notice shall be included in all
  copies or substantial portions of the Software.
  
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
  IN THE SOFTWARE.
]]

-- Linear implementation of in-mutable and interned tuples for Lua. It is linear
-- because tuples are stored into a linear table. A different approach would be
-- store tuples into an inverted prefix tree (trie). Major difference between
-- both approaches is that linear implementation needs more memory but has
-- better indexing time, while prefix tree implementation needs less memory but
-- has worst indexing time.

local tuple = {
  _VERSION = "0.1",
  _NAME = "tuple",
}

if _VERSION ~= "Lua 5.3" then
  -- the following hack is needed to allow unpack over tuples
  local table = require "table"
  local function table_unpack(t,i,n)
    i = i or 1
    n = n or #t
    if i <= n then
      return t[i], table_unpack(t, i + 1, n)
    end
  end
  table.unpack = table_unpack
  unpack = table_unpack
end

-- libraries import
local assert = assert
local getmetatable = getmetatable
local ipairs = ipairs
local pairs = pairs
local select = select
local tostring = tostring
local type = type
local bit32_band = bit32.band
local bit32_lshift = bit32.lshift
local bit32_rshift = bit32.rshift
local bit32_bxor = bit32.bxor
local math_max = math.max
local string_byte = string.byte
local string_format = string.format
local string_sub = string.sub
local table_concat = table.concat
local table_pack = table.pack

-- constants
local BYTE_MASK = 0x000000FF
local WORD_MASK = 0xFFFFFFFF
local MAX_NUMBER = 2^32
local MAX_BUCKET_HOLES_RATIO = 100
local NUM_BUCKETS = 2^18
local WEAK_MT = { __mode="v" }

-- the list of tuples is a hash table with a maximum of NUM_BUCKETS
local list_of_tuples = {}
-- a table with metadata of tuples, indexed by tuples reference
local tuples_metadata = setmetatable({}, { __mode="k" })

-- iterate over all chars of a string
local function char_iterator(data,j)
  j=j+1
  if j < #data then return j,string.byte(data:sub(j,j)) end
end

-- converts a number into a binary string, for hash computation purposes
local function number_iterator(data,j)
   local d = data
   if data < 1 then d = data * 10 end
   if j < 4 then
	  local v = bit32_band(bit32_rshift(d,j*8),BYTE_MASK)
	  return j+1,v
   end
end

-- forward declaration
local compute_hash
-- iterates over all the bytes of a value
local function iterate(data)
  local tt = type(data)
  if tt == "string" then
    return char_iterator,data,0
  elseif tt == "number" then
    assert(data < MAX_NUMBER, "Only valid for 32 bit numbers")
    return number_iterator,data,0
  elseif tt == "table" then
    return iterate(compute_hash(data))
  elseif tt == "nil" then
    return function() end
  else
    local str = assert(tostring(data),
		       "Needs an array with numbers, tables or strings")
    return iterate(str)
  end
end

-- computes the hash of a given tuple candidate
compute_hash = function(t)
  local h = 0
  for i=1,#t do
    local v = t[i]
    -- hash computation for every byte number in iterator over v
    for j,c in iterate(v) do
      h = h + c
      h = h + bit32_lshift(h,10)
      h = bit32_bxor(h,  bit32_rshift(h,6))
      -- compute hash modules 2^32
      h = bit32_band(h, WORD_MASK)
    end
  end
  h = h + bit32_rshift(h,3)
  h = bit32_bxor(h, bit32_lshift(h,11))
  h = h + bit32_lshift(h,15)
  -- compute hash modules 2^32
  h = bit32_band(h, WORD_MASK)
  return h
end

-- tuple instances has this metatable
local tuple_instance_mt = {
  -- disallow to change metatable
  __metatable = false,
  -- avoid to insert new elements
  __newindex = function(self) error("Unable to modify a tuple") end,
  -- concatenates two tuples or a tuple with a number, string or another table
  __concat = function(a,b)
    if type(a) ~= "table" then a,b=b,a end
    local aux = {}
    for i=1,#a do aux[#aux+1] = a[i] end
    if type(b) == "table" then
      for i=1,#b do aux[#aux+1] = b[i] end
    else
      aux[#aux+1] = b
    end
    return tuple(aux)
  end,
}

-- functions for accessing tuple metadata
local unwrap = function(self) return tuples_metadata[self][1] end
local len = function(self) return tuples_metadata[self][2] end
local hash = function(self) return tuples_metadata[self][3] end
--
local proxy_metatable = {
  __metatable = "is_tuple",
  __index = function(self,k) return unwrap(self)[k] end,
  __newindex = function(self) error("Tuples are in-mutable data") end,
  __len = function(self) return len(self) end,
  -- convert it to a string like: tuple{ a, b, ... }
  __tostring = function(self)
    local t = unwrap(self)
    local result = {}
    for i=1,#self do
      local v = t[i]
      if type(v) == "string" then v = string_format("%q",v) end
      result[#result+1] = tostring(v)
    end
    return table_concat({"tuple{",table_concat(result, ", "),"}"}, " ")
  end,
  __lt = function(self,other)
    local t = unwrap(self)
    if type(other) ~= "table" then return false
    elseif #t < #other then return true
    elseif #t > #other then return false
    elseif t == other then return false
    else
      for i=1,#t do
	if t[i] > other[i] then return false end
      end
      return true
    end
  end,
  __le =  function(self,other)
    local t = unwrap(self)
    -- equality is comparing references (tuples are in-mutable and interned)
    if self == other then return true end
    return self < other
  end,
  __pairs = function(self) return pairs(unwrap(self)) end,
  __ipairs = function(self) return ipairs(unwrap(self)) end,
  __concat = function(self,other) return unwrap(self) .. other end,
  __gc = function(self)
    local h = hash(self)
    if h then
      local p = h % NUM_BUCKETS
      if list_of_tuples[p] and not next(list_of_tuples[p]) then
	list_of_tuples[p] = nil
      end
    end
  end,
  __mode = "v",
}

-- returns a wrapper table (proxy) which shades the data table, allowing
-- in-mutability in Lua, it receives the table data and the number of elements
local function proxy(tpl,n)
  setmetatable(tpl, tuple_instance_mt)
  local ref = setmetatable({}, proxy_metatable)
  -- the proxy table has an in-mutable metatable, and stores in tuples_metadata
  -- the real tuple data and the number of elements
  tuples_metadata[ref] = { tpl, n }
  return ref
end

-- builds a candidate tuple given a table, recursively converting tables in new
-- tuples
local function tuple_constructor(t)
  -- take n from the variadic args or from t length
  local n = t.n or #t
  local new_tuple = { }
  for i=1,n do
    local v = t[i]
    assert(type(i) == "number" and i>0, "Needs integer keys > 0")
    if type(v) == "table" then
      -- recursively converts tables in new tuples
      new_tuple[i] = tuple(v)
    else
      -- copies the value
      new_tuple[i] = v
    end
  end
  -- returns a proxy to the new_tuple table with #t length
  return proxy(new_tuple,n)
end

-- metatable of tuple "class" table
local tuple_mt = {
  -- tuple constructor doesn't allow table loops
  __call = function(self, ...)
    local n = select('#', ...)
    local t = table_pack(...) assert(#t == n) if #t == 1 then t = t[1] end
    if type(t) ~= "table" then
      -- non-table elements are unpacked when only one is given
      return t
    else
      -- check if the given table is a tuple, if it is the case, just return it
      local mt = getmetatable(t) if mt=="is_tuple" then return t end
      -- create a new tuple candidate
      local new_tuple = tuple_constructor(t)
      local h = compute_hash(new_tuple)
      local p = h % NUM_BUCKETS
      local bucket = (list_of_tuples[p] or setmetatable({}, WEAK_MT))
      list_of_tuples[p] = bucket
      -- Count the number of elements in the bucket and the maximum non-nil key.
      -- In case the relation between this two values was greater than
      -- MAX_BUCKET_HOLES_RATIO, the bucket will be rearranged to remove all nil
      -- holes.
      local max,n = 0,0
      for i,vi in pairs(bucket) do
	local equals = true
	-- check equality by comparing all the elements one-by-one
        if #vi == #new_tuple then
          for j=1,#vi do
            local vj = vi[j]
            if vj ~= new_tuple[j] then equals=false break end
          end
        else
          equals = false
        end
	-- BREAKS the execution flow in case the tuple exists in the bucket
	if equals == true then return vi end
	max = math_max(max,i)
	n = n+1
      end
      -- rearrange the bucket when the ratio achieves the threshold
      if max/n > MAX_BUCKET_HOLES_RATIO then
	local new_bucket = {}
	for i,vi in pairs(bucket) do new_bucket[#new_bucket+1] = vi end
	list_of_tuples[p], bucket = new_bucket, new_bucket
	max = #bucket
	collectgarbage("collect")
      end
      bucket[max+1] = new_tuple
      -- take note of the hash number into __metatable array, position 4
      tuples_metadata[new_tuple][3] = h
      return new_tuple
    end
  end,
}
setmetatable(tuple, tuple_mt)

----------------------------------------------------------------------------
------------------------------ UNIT TEST -----------------------------------
----------------------------------------------------------------------------

tuple.utest = function()
  local a = tuple(2,{4,5},"a")
  local b = tuple(4,5)
  local c = tuple(2,a[2],"a")
  assert(a == c)
  assert(b == a[2])
  assert(b == c[2])
  a,b,c = nil,nil,nil
  collectgarbage("collect")
  --
  local aux = {} for i=1,10000 do aux[tuple(i,i)] = i end
  assert(tuple.stats() == 10000)
  collectgarbage("collect")
  assert(tuple.stats() == 10000)
  aux = nil
  collectgarbage("collect")
  assert(tuple.stats() == 0)
  --
  assert(not getmetatable(tuple(1)))
end

-- returns the number of tuples "alive", the number of used buckets, and the
-- loading factor of the hash table
tuple.stats = function()
  local num_buckets = 0
  local size = 0
  for k1,v1 in pairs(list_of_tuples) do
    num_buckets = num_buckets + 1
    for k2,v2 in pairs(v1) do size=size+1 end
  end
  if num_buckets == 0 then num_buckets = 1 end
  local msz = 0
  for _,v in pairs(tuples_metadata) do msz = msz + 1 end
  return size,num_buckets,size/NUM_BUCKETS,msz
end

return tuple
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2020 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

--- <h1>Zencode language parser</h1>
--
-- <a href="https://dev.zenroom.org/zencode/">Zencode</a> is a Domain
-- Specific Language (DSL) made to be understood by humans. Its
-- purpose is detailed in <a
-- href="https://files.dyne.org/zenroom/Zencode_Whitepaper.pdf">the
-- Zencode Whitepaper</a> and DECODE EU project.
--
-- @module ZEN
--
-- @author Denis "Jaromil" Roio
-- @license AGPLv3
-- @copyright Dyne.org foundation 2018-2020
--
-- The Zenroom VM is capable of parsing specific scenarios written in
-- Zencode and execute high-level cryptographic operations described
-- in them; this is to facilitate the integration of complex
-- operations in software and the non-literate understanding of what a
-- distributed application does.
--
-- This section doesn't provide the documentation on how to write
-- Zencode. Refer to the links above to learn it. This documentation
-- continues to illustrate internals: how the Zencode direct-syntax
-- parser is made, how it integrates in the Zenroom memory model.

-- This is also the reference implementation to learn how to code
-- Zencode simple scenario using Zeroom's Lua.
--
-- @module ZEN


local zencode = {
   given_steps = {},
   when_steps = {},
   then_steps = {},
   schemas = { },
   id = 0,
   AST = {},
   eval_cache = { }, -- zencode_eval if...then conditions
   checks = { version = false }, -- version, scenario checked, etc.
   OK = true -- set false by asserts
}

require('zenroom_ast')


-- set_sentence
-- set_rule

local function new_state_machine()
   local machine = MACHINE.create({
		 initial = 'init',
		 events = {
			{ name = 'enter_rule',     from = { 'init', 'rule', 'scenario' }, to = 'rule' },
			{ name = 'enter_scenario', from = { 'init', 'rule', 'scenario' }, to = 'scenario' },
			{ name = 'enter_given',    from = { 'init', 'rule', 'scenario' }, to = 'given' },
			{ name = 'enter_given',    from =   'given',             to = 'given' },
			{ name = 'enter_and',      from =   'given',             to = 'given' },
			{ name = 'enter_when',     from =   'given',             to = 'when' },
			{ name = 'enter_when',     from =   'when',              to = 'when' },
			{ name = 'enter_and',      from =   'when',              to = 'when' },
			{ name = 'enter_then',     from = { 'given', 'when' },   to = 'then' },
			{ name = 'enter_then',     from =   'then',              to = 'then' },
			{ name = 'enter_and',      from =   'then',              to = 'then' }
		 },
		 callbacks = {
			-- msg is a table: { msg = "string", Z = ZEN (self) }
			onscenario = function(self, event, from, to, msg)
			   -- first word until the colon
			   local scenarios = strtok(string.match(msg.msg, "[^:]+"))
			   for k,scen in ipairs(scenarios) do
				  if k ~= 1 then -- skip first (prefix)
					 require_once("zencode_"..trimq(scen))
					 ZEN:trace("Scenario "..scen)
					 return
				  end
			   end
			end,
			onrule = function(self, event, from, to, msg)
			   -- process rules immediately
			   set_rule(msg)
			end,
			-- set_sentence from zencode_ast
			ongiven = set_sentence,
			onwhen  = set_sentence,
			onthen  = set_sentence,
			onand = set_sentence
		 }
})
   return machine
end

-- Zencode HEAP globals
IN = { }         -- Given processing, import global DATA from json
IN.KEYS = { }    -- Given processing, import global KEYS from json
TMP = TMP or { } -- Given processing, temp buffer for ack*->validate->push*
ACK = ACK or { } -- When processing,  destination for push*
OUT = OUT or { } -- print out
AST = AST or { } -- AST of parsed Zencode
WHO = nil
_G['ZEN_traceback'] = "Zencode traceback:\n"



---------------------------------------------------------------
-- ZENCODE PARSER

function zencode:begin()
   self.id = 0
   self.AST = {}
   self.eval_cache = { }
   self.checks = { version = false } -- version, scenario checked, etc.
   self.OK = true -- set false by asserts

   -- Reset HEAP
   self.machine = { }
   IN = { }         -- Given processing, import global DATA from json
   IN.KEYS = { }    -- Given processing, import global KEYS from json
   TMP = { } -- Given processing, temp buffer for ack*->validate->push*
   ACK = { } -- When processing,  destination for push*
   OUT = { } -- print out
   AST = { } -- AST of parsed Zencode
   WHO = nil
   collectgarbage'collect'
   -- Zencode init traceback
   _G['ZEN_traceback'] = "Zencode traceback:\n"
   self.machine = new_state_machine()
return true
end


function zencode:parse(text)
   if  #text < 9 then -- strlen("and debug") == 9
   	  warn("Zencode text too short to parse")
   	  return false end
   -- xxx(3,text)
   for line in zencode_newline_iter(text) do
	  if zencode_isempty(line) then goto continue end
	  if zencode_iscomment(line) then goto continue end
	  -- max length for single zencode line is #define MAX_LINE
	  -- hard-coded inside zenroom.h
	  local prefix = parse_prefix(line)
	  self.assert(prefix, "Invalid Zencode line: "..line)
	  local defs -- parse in what phase are we
	  self.OK = true
	  exitcode(0)
	  -- try to enter the machine state named in prefix
	  -- xxx(3,"Zencode machine enter_"..prefix..": "..text)
	  local fm = self.machine["enter_"..prefix]
	  self.assert(fm,"Invalid Zencode prefix: "..prefix)
	  self.assert(fm(self.machine, { msg = line, Z = self }),
				  line.."\n    "..
					 "Invalid transition from "
					 ..self.machine.current.." to Rule block")
	  ::continue::
   end
   collectgarbage'collect'
   return true
end

function zencode:trace(src)
   -- take current line of zencode
   local tr = trim(src)
   -- TODO: tabbing, ugly but ok for now
   if string.sub(tr,1,1) == '[' then
	  _G['ZEN_traceback'] = _G['ZEN_traceback']..tr.."\n"
   else
	  _G['ZEN_traceback'] = _G['ZEN_traceback'].." .  "..tr.."\n"
   end
	  -- "    -> ".. src:gsub("^%s*", "") .."\n"
end

-- trace function execution also on success
function zencode:ftrace(src)
   -- take current line of zencode
   _G['ZEN_traceback'] = _G['ZEN_traceback']..
	  " D  ZEN:"..trim(src).."\n"
   -- "    -> ".. src:gsub("^%s*", "") .."\n"
end

-- log zencode warning in traceback
function zencode:wtrace(src)
   -- take current line of zencode
   _G['ZEN_traceback'] = _G['ZEN_traceback']..
	  " W  ZEN:"..trim(src).."\n"
   -- "    -> ".. src:gsub("^%s*", "") .."\n"
end

function zencode:run()
   -- runtime checks
   if not ZEN.checks.version then
	  warn("Zencode is missing version check, please add: rule check version N.N.N")
   end
   -- HEAP setup
   IN = { } -- import global DATA from json
   if DATA then
	  -- if plain array conjoin into associative
	  IN = CONF.input.format.fun(DATA) or { }
   end
   IN.KEYS = { } -- import global KEYS from json
   if KEYS then IN.KEYS = CONF.input.format.fun(KEYS) or { } end
   -- EXEC zencode
   for i,x in sort_ipairs(self.AST) do
	  ZEN:trace(x.source)

	  -- HEAP integrity guard
	  if CONF.heapguard then
		 if x.section == 'then' or x.section == 'when' then
			-- delete IN memory
			IN.KEYS = { }
			IN = { }
			collectgarbage'collect'
			-- guard ACK's contents on section switch
			zenguard(ACK)
		 end
	  end

	  ZEN.OK = true
	  exitcode(0)
      local ok, err = pcall(x.hook,table.unpack(x.args))
      if not ok or not ZEN.OK then
	  	 if err then ZEN:trace("[!] "..err) end
		 fatal(x.source) -- traceback print inside
	  end
   end
   -- PRINT output
   ZEN:trace("--- Zencode execution completed")
   if type(OUT) == 'table' then
	  ZEN:trace("+++ Adding setup information to { OUT }")
	  if CONF.output.versioning == true then
		 OUT.zenroom = { }
		 OUT.zenroom.version = VERSION.original
		 -- OUT.zenroom.scenario = ZEN.scenario
	  end
	  ZEN:trace("<<< Encoding { OUT } to "..CONF.output.format.name)
	  print(CONF.output.format.fun(OUT))
	  ZEN:trace(">>> Encoding successful")
   else -- this should never occur in zencode, OUT is always a table
	  ZEN:trace("<<< Printing OUT (plain format, not a table)")
	  print(OUT)
   end
   -- print the AST to stderr
   if CONF.output.AST == true then
	  printerr("#+AST_BEGIN")
	  printerr(CONF.output.format.fun(ZEN.AST))
	  printerr("#+AST_END")
   end
end

function zencode.debug()
   warn(ZEN_traceback)
   I.warn({ HEAP = { IN = IN,
					TMP = TMP,
					ACK = ACK,
					OUT = OUT }})
end

function zencode.debug_json()
   write(JSON.encode({ TRACE = ZEN_traceback,
                       HEAP = { IN = IN,
                                TMP = TMP,
                                ACK = ACK,
                                OUT = OUT }}))
end

function zencode.assert(condition, errmsg)
   if condition then return true end
   -- ZEN.debug() -- prints all data in memory
   ZEN:trace("ERR "..errmsg)
   ZEN.OK = false
   exitcode(1);
   error(errmsg, 3)
end

return zencode
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- COCONUT implementation in Zencode

COCONUT = require_once('crypto_coconut')


-- convenient alias
local get = ZEN.get


ZEN.add_schema({
	  -- credential keypair (elgamal)
      credential_keypair = function(obj)
         return { public  = get(obj, 'public', ECP.new),
                  private = get(obj, 'private', INT.new) } end
})
-- credential keypair operations
When("I create the credential keypair", function()
		-- sk = rand, pk = G * sk
		local tmp = { private = INT.random() }
		tmp.public = ECP.generator() * tmp.private
		ZEN:pick('credential_keypair', tmp)
		ZEN:validate('credential_keypair')
		ZEN:ack('credential_keypair')
end)

-- issuer authority kepair operations
ZEN.add_schema({
	  -- certificate authority (ca) / issuer keypair
      issuer_sign = function(obj)
              return { x = get(obj, 'x', INT.new),
                       y = get(obj, 'y', INT.new) }
	  end,
      verifier = function(obj)
		 return { alpha = get(obj, 'alpha', ECP2.new),
				  beta  = get(obj, 'beta', ECP2.new) }
	  end,
	  issuer_keypair = function(obj) -- recursive import
		 return { issuer_sign   = ZEN:validate_recur(obj.issuer_sign, 'issuer_sign'),
				  verifier = ZEN:validate_recur(obj.verifier, 'verifier') }
	  end
})

When("I create the issuer keypair", function()
		local t = { }
		t.sk, t.vk = COCONUT.ca_keygen()
		ZEN:pick('issuer_keypair', { issuer_sign = t.sk,
									 verifier = t.vk })
		ZEN:validate('issuer_keypair')
		ZEN:ack('issuer_keypair')
end)

-- request credential signatures
ZEN.add_schema({
     -- lambda
	  credential_request = function(obj)
		local req = { c = { a = get(obj.c, 'a', ECP.new),
							b = get(obj.c, 'b', ECP.new) },
					  pi_s = { rr = get(obj.pi_s, 'rr', INT.new),
							   rm = get(obj.pi_s, 'rm', INT.new),
							   rk = get(obj.pi_s, 'rk', INT.new),
							   c =  get(obj.pi_s, 'c',  INT.new)  },
					  commit = get(obj, 'commit', ECP.new),
					  public = get(obj, 'public', ECP.new) }
		ZEN.assert(COCONUT.verify_pi_s(req),
                   "Error in credential request: proof is invalid (verify_pi_s)")
		return req
	  end
})

When("I create the credential request", function()
		ZEN.assert(ACK.credential_keypair.private,
				   "Private key not found in credential keypair")
		ZEN:pick('credential_request',
				 COCONUT.prepare_blind_sign(ACK.credential_keypair.public,
											ACK.credential_keypair.private))
		ZEN:validate('credential_request')
		ZEN:ack('credential_request')
end)


-- issuer's signature of credentials
ZEN.add_schema({
	  -- sigmatilde
	  credential_signature = function(obj)
		 return { h = get(obj, 'h', ECP.new),
				  b_tilde = get(obj, 'b_tilde', ECP.new),
				  a_tilde = get(obj, 'a_tilde', ECP.new) } end,
	  -- aggsigma: aggregated signatures of ca issuers
	  credentials = function(obj)
		 return { h = get(obj, 'h', ECP.new),
				  s = get(obj, 's', ECP.new) } end,
})
When("I create the credential signature", function()
		ZEN.assert(WHO, "Issuer is not known")
        ZEN.assert(ACK.credential_request, "No valid signature request found.")
        ZEN.assert(ACK.issuer_keypair.issuer_sign, "No valid issuer signature keys found.")
        ACK.credential_signature =
           COCONUT.blind_sign(ACK.issuer_keypair.issuer_sign,
                              ACK.credential_request)
		ACK.verifier = ACK.issuer_keypair.verifier
end)
When("I create the credentials", function()
        ZEN.assert(ACK.credential_signature, "Credential signature not found")
        ZEN.assert(ACK.credential_keypair.private, "Credential private key not found")
        -- prepare output with an aggregated sigma credential
        -- requester signs the sigma with private key
        ACK.credentials = COCONUT.aggregate_creds(
		   ACK.credential_keypair.private, { ACK.credential_signature })
end)


ZEN.add_schema({
	  -- theta: blind proof of certification
	  credential_proof = function(obj)
		 return { nu = get(obj, 'nu', ECP.new),
				  kappa = get(obj, 'kappa', ECP2.new),
				  pi_v = { c = get(obj.pi_v, 'c', INT.new),
						   rm = get(obj.pi_v, 'rm', INT.new),
						   rr = get(obj.pi_v, 'rr', INT.new) },
				  sigma_prime = { h_prime = get(obj.sigma_prime, 'h_prime', ECP.new),
								  s_prime = get(obj.sigma_prime, 's_prime', ECP.new) } }
	  end
})

-- aggregated verifiers schema is same as a single verifier
ZEN.add_schema({verifiers = ZEN.schemas['verifier']})

When("I aggregate the verifiers", function()
		for k,v in pairs(ACK.verifier) do
		-- if ACK.verifier.alpha then
		   ACK.verifiers = v
		end
		-- TODO: aggregate all array
end)

When("I create the credential proof", function()
        ZEN.assert(ACK.verifiers, "No issuer verification keys are selected")
		ZEN.assert(ACK.credential_keypair.private,
				   "Credential private key not found")
		ZEN.assert(ACK.credentials, "Credentials not found")
		ACK.credential_proof =
		   COCONUT.prove_creds(ACK.verifiers,
							   ACK.credentials,
							   ACK.credential_keypair.private)
end)
When("I verify the credential proof", function()
        ZEN.assert(ACK.credential_proof, "No valid credential proof found")
        ZEN.assert(ACK.verifiers, "Verifier of aggregated issuer keys not found")
        ZEN.assert(
           COCONUT.verify_creds(ACK.verifiers,
								ACK.credential_proof),
           "Credential proof does not validate")
end)


-- petition
ZEN.add_schema({
	  petition_scores = function(obj)
		 return({
			   pos = { left  = get(obj.pos, 'left', ECP.new),
					   right = get(obj.pos, 'right', ECP.new) },
			   neg = { left  = get(obj.neg, 'left', ECP.new),
					   right = get(obj.neg, 'right', ECP.new) } })
	  end,
	  petition = function(obj)
		 local res = { uid = get(obj,'uid'),
					   owner = get(obj, 'owner', ECP.new),
					   scores = ZEN:valid('petition_scores',obj.scores) }
		 if type(obj.vkeys) == 'table' then res.vkeys = ZEN:valid('verifier',obj.vkeys) end
		 if type(obj.list) == 'table' then
			res.list = { }
			for k,v in sort_ipairs(obj.list) do
			   table.insert(res.list,ZEN:import(v))
			end
		 end
		 return res
	  end,
	 petition_signature = function(obj)
		return { proof = ZEN:valid('credential_proof',obj.proof),
				 uid_signature = get(obj, 'uid_signature', ECP.new),
				 uid_petition = get(obj, 'uid_petition') }
	 end,
	 
	 petition_tally = function(obj)
		local dec = { }
		dec.neg = get(obj.dec, 'neg', ECP.new)
		dec.pos = get(obj.dec, 'pos', ECP.new)
		return { uid = get(obj,'uid'),
				 c = get(obj, 'c', INT.new),
				 dec = dec,
				 rx = get(obj, 'rx', INT.new) }
	 end
	 
})


When("I create the petition ''", function(uid)
		ZEN:pick('petition',
				 { uid = ZEN:import(uid, O.from_string),
				   owner = ACK.credential_keypair.public,
				   scores = { pos = { left = ECP.infinity(),
									  right = ECP.infinity() },
							  neg = { left = ECP.infinity(),
									  right = ECP.infinity()  } }
		})
		-- pass validation by hand since we just created it
		TMP.valid = true
 		ZEN:ack('petition')
		-- generate an ECDH signature of the (encoded) petition using the
		-- credential keys
		-- ecdh = ECDH.new()
		-- ecdh:private(ACK.cred_kp.private)
		-- ACK.petition_ecdh_sign = { ecdh:sign(MSG.pack(OUT.petition)) }
		-- OUT.petition_ecdh_sign = map(ACK.petition_ecdh_sign, hex)
end)

When("I verify the new petition to be empty", function()
        ZEN.assert(ECP.isinf(ACK.petition.scores.pos.left),
                   "Invalid new petition: positive left score is not zero")
        ZEN.assert(ECP.isinf(ACK.petition.scores.pos.right),
                   "Invalid new petition: positive right score is not zero")
        ZEN.assert(ECP.isinf(ACK.petition.scores.neg.left),
                   "Invalid new petition: negative left score is not zero")
        ZEN.assert(ECP.isinf(ACK.petition.scores.neg.right),
                   "Invalid new petition: negative right score is not zero")
end)

When("I create the petition signature ''", function(uid)
        ZEN.assert(ACK.verifiers, "Verifier of aggregated issuer keys not found")
		ZEN.assert(ACK.credential_keypair.private,
				   "Credential private key not found")
		ZEN.assert(ACK.credentials, "Signed credential not found")
		local Theta
		local zeta
		local ack_uid = ZEN:import(uid, O.from_string)
		Theta, zeta = COCONUT.prove_cred_petition(
		   ACK.verifiers,
		   ACK.credentials,
		   ACK.credential_keypair.private, ack_uid)
		ZEN:pick('petition_signature',
				 { proof = Theta,
				   uid_signature = zeta,
				   uid_petition = ack_uid })
		ZEN:validate('petition_signature')
		ZEN:ack('petition_signature')
end)

When("I verify the signature proof is correct", function()
		ZEN.assert(
		   COCONUT.verify_cred_petition(ACK.verifiers,
										ACK.petition_signature.proof,
										ACK.petition_signature.uid_signature,
										ACK.petition_signature.uid_petition),
		   "Petition signature is invalid")
end)

When("the petition signature is not a duplicate", function()
		local k = ZEN:export(ACK.petition_signature.uid_signature)
		if type(ACK.petition.list) == 'table' then
		   ZEN.assert(
			  ACK.petition.list[k] == nil,
			  "Duplicate petition signature detected")
		   ACK.petition.list[k] = true
		else
		   ACK.petition.list = { }
		   table.insert(ACK.petition.list,
						get(ACK.petition_signature, 'uid_signature', ECP.new))
		end
end)

When("the petition signature is just one more", function()
		-- verify that the signature is +1 (no other value supported)
		ACK.petition_signature.one =
		   COCONUT.prove_sign_petition(ACK.petition.owner, BIG.new(1))
		ZEN.assert(COCONUT.verify_sign_petition(ACK.petition.owner,
												ACK.petition_signature.one),
				   "Coconut petition signature adds more than one signature")
end)

When("I add the signature to the petition", function()
		-- add the signature to the petition count
		local scores = ACK.petition.scores
		local psign  = ACK.petition_signature.one
		scores.pos.left =  scores.pos.left  + psign.scores.pos.left
		scores.pos.right = scores.pos.right + psign.scores.pos.right
		scores.neg.left =  scores.neg.left  + psign.scores.neg.left
		scores.neg.right = scores.neg.right + psign.scores.neg.right
		-- TODO: ZEN:push({'petition' ,'scores'}
		ACK.petition.scores = scores
end)

When("I create a petition tally", function()
        ZEN.assert(ACK.credential_keypair.private,
				   "Private key not found in credential keypair")
		ZEN.assert(ACK.petition, "Petition not found")
		ACK.petition_tally = COCONUT.prove_tally_petition(
		   ACK.credential_keypair.private, ACK.petition.scores)
		ACK.petition_tally.uid = ACK.petition.uid
end)

When("I count the petition results", function()
		ZEN.assert(ACK.petition, "Petition not found")
		ZEN.assert(ACK.petition_tally, "Tally not found")
		ZEN.assert(ACK.petition_tally.uid == ACK.petition.uid,
				   "Tally does not correspond to petition")
		OUT.petition_results = COCONUT.count_signatures_petition(
		   ACK.petition.scores, ACK.petition_tally).pos
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.



--- Zencode data internals


-- init schemas
function ZEN.add_schema(arr)
   local _illegal_schemas = { -- const
	  whoami = true
   }
   for k,v in pairs(arr) do
	  -- check overwrite / duplicate to avoid scenario namespace clash
	  ZEN.assert(not ZEN.schemas[k], "Add schema denied, already registered schema: "..k)
	  ZEN.assert(not _illegal_schemas[k], "Add schema denied, reserved name: "..k)
	  ZEN.schemas[k] = v
   end
end


-- basic encoding schemas
ZEN.add_schema({
	  base64 = function(obj) return ZEN:convert(obj, OCTET.from_base64) end,
	  url64  = function(obj) return ZEN:convert(obj, OCTET.from_url64)  end,
	  hex =    function(obj) return ZEN:convert(obj, OCTET.from_hex) end,
	  str =    function(obj) return ZEN:convert(obj, OCTET.from_string) end,
})


-- init statements
function Given(text, fn)
   -- xxx(3,"Scenario '"..ZEN.scenario.."' add given statement: "..text)
   ZEN.assert(not ZEN.given_steps[text],
   			  "Conflicting statement loaded by scenario: "..text)
   ZEN.given_steps[text] = fn
end
function When(text, fn)
   -- xxx(3,"Scenario '"..ZEN.scenario.."' add when statement: "..text)
   ZEN.assert(not ZEN.when_steps[text],
   			  "Conflicting statement loaded by scenario: "..text)
   ZEN.when_steps[text] = fn
end
function Then(text, fn)
   -- xxx(3,"Scenario '"..ZEN.scenario.."' add then statement: "..text)
   ZEN.assert(not ZEN.then_steps[text],
   			  "Conflicting statement loaded by scenario : "..text)
   ZEN.then_steps[text] = fn
end

-- the main security concern in this Zencode module is that no data
-- passes without validation from IN to ACK or from inline input.

-- TODO: return the prefix of an encoded string if found
ZEN.prefix = function(str)
   t = type(str)
   if t ~= "string" then return nil end
   if str:sub(4,4) ~= ":" then return nil end
   return str:sub(1,3)
end

ZEN.get = function(obj, key, conversion)
   ZEN.assert(obj, "ZEN.get no object found")
   ZEN.assert(type(key) == "string", "ZEN.get key is not a string")
   ZEN.assert(not conversion or type(conversion) == 'function',
			  "ZEN.get invalid conversion function")
   local k
   if key == "." then k = obj
   else k = obj[key] end
   ZEN.assert(k, "Key not found in object conversion: "..key)
   local res = nil
   local t = type(k)

   if iszen(t) and conversion then res = conversion(k) goto ok end
   if iszen(t) and not conversion then res = k goto ok end
   if t == 'string' and conversion == str then res = k goto ok end
   if t == 'string' and conversion and conversion ~= str then
	  res = ZEN:import(k, conversion) goto ok end
   if t == 'string' and not conversion then
	  res = ZEN:import(k)
	  goto ok
   end
   if t == 'number' then res = k end
   ::ok::
   assert(ZEN.OK and res, "ZEN.get on invalid key: "..key.." ("..t..")")
   return res
end


-- import function to have recursion of nested data structures
-- according to their stated schema
function ZEN:valid(sname, obj)
   ZEN.assert(sname, "Import error: schema name is nil")
   ZEN.assert(obj, "Import error: object is nil '"..sname.."'")
   local s = ZEN.schemas[sname]
   ZEN.assert(s, "Import error: schema not found '"..sname.."'")
   ZEN.assert(type(s) == 'function', "Import error: schema is not a function '"..sname.."'")
   return s(obj)
end

--- Given block (IN read-only memory)
-- @section Given

---
-- Declare 'my own' name that will refer all uses of the 'my' pronoun
-- to structures contained under this name.
--
-- @function ZEN:Iam(name)
-- @param name own name to be saved in WHO
function ZEN:Iam(name)
   if name then
	  ZEN.assert(not WHO, "Identity already defined in WHO")
	  ZEN.assert(type(name) == "string", "Own name not a string")
	  WHO = name
   else
	  ZEN.assert(WHO, "No identity specified in WHO")
   end
   assert(ZEN.OK)
end


-- local function used inside ZEN:pick*
-- try obj.*.what (TODO: exclude KEYS and WHO)
local function inside_pick(obj, what)
   ZEN.assert(obj, "ZEN:pick object is nil")
   -- ZEN.assert(I.spy(type(obj)) == "table", "ZEN:pick object is not a table")
   ZEN.assert(type(what) == "string", "ZEN:pick object index is not a string")
   local got
   if type(obj) == 'string' then  got = obj
   else got = obj[what] end
   if got then
	  -- ZEN:ftrace("inside_pick found "..what.." at object root")
	  goto gotit
   end
   for k,v in pairs(obj) do -- search 1 deeper
      if type(v) == "table" and v[what] then
         got = v[what]
         -- ZEN:ftrace("inside_pick found "..k.."."..what)
         break
      end
   end
   ::gotit::
   return got
end

---
-- Pick a generic data structure from the <b>IN</b> memory
-- space. Looks for named data on the first and second level and makes
-- it ready for @{validate} or @{ack}.
--
-- @function ZEN:pick(name, data)
-- @param name string descriptor of the data object
-- @param data[opt] optional data object (default search inside IN.*)
-- @return true or false
function ZEN:pick(what, obj)
   if obj then -- object provided by argument
	  TMP = { data = obj,
			  root = nil,
			  schema = what,
			  valid = false }
	  return(ZEN.OK)
   end
   local got
   got = inside_pick(IN.KEYS, what) or inside_pick(IN,what)
   ZEN.assert(got, "Cannot find '"..what.."' anywhere")
   TMP = { root = nil,
		   data = ZEN:import(got),
		   valid = false,
		   schema = what }
   assert(ZEN.OK)
   ZEN:ftrace("pick found "..what)
end

---
-- Pick a data structure named 'what' contained under a 'section' key
-- of the at the root of the <b>IN</b> memory space. Looks for named
-- data at the first and second level underneath IN[section] and moves
-- it to TMP[what][section], ready for @{validate} or @{ack}. If
-- TMP[what] exists already, every new entry is added as a key/value
--
-- @function ZEN:pickin(section, name)
-- @param section string descriptor of the section containing the data
-- @param name string descriptor of the data object
-- @return true or false
function ZEN:pickin(section, what)
   ZEN.assert(section, "No section specified")
   local root -- section
   local got  -- what
   root = inside_pick(IN.KEYS,section)
   if root then --    IN KEYS
	  got = inside_pick(root, what)
	  if got then goto found end
   end
   root = inside_pick(IN,section)
   if root then --    IN
	  got = inside_pick(root, what)
	  if got then goto found end
   end
   ZEN.assert(got, "Cannot find '"..what.."' inside '"..section.."'")
   -- TODO: check all corner cases to make sure TMP[what] is a k/v map
   ::found::
   TMP = { root = section,
		   data = ZEN:import(got),
		   valid = false,
		   schema = what }
   assert(ZEN.OK)
   ZEN:ftrace("pickin found "..what.." in "..section)
end

---
-- Optional step inside the <b>Given</b> block to execute schema
-- validation on the last data structure selected by @{pick}.
--
-- @function ZEN:validate(name)
-- @param name string descriptor of the data object
-- @param schema[opt] string descriptor of the schema to validate
-- @return true or false
function ZEN:validate(name, schema)
   local schema_name = schema or TMP.schema or name -- if no schema then coincides with name
   ZEN.assert(name, "ZEN:validate error: argument is nil")
   ZEN.assert(TMP, "ZEN:validate error: TMP is nil")
   -- ZEN.assert(TMP.schema, "ZEN:validate error: TMP.schema is nil")
   -- ZEN.assert(TMP.schema == name, "ZEN:validate() TMP does not contain "..name)
   ZEN.assert(TMP.data, "ZEN:validate error: data not found in TMP for schema "..name)
   local schema_f = ZEN.schemas[schema_name]
   ZEN.assert(schema_f, "ZEN:validate error: "..schema_name.." schema not found")
   ZEN.assert(type(schema_f) == 'function',
			  "ZEN:validate error: schema is not a function for "..schema_name)
   ZEN:ftrace("validate "..name.. " with schema "..schema_name)
   TMP.data = schema_f(TMP.data) -- overwrite
   ZEN.assert(TMP.data, "ZEN:validate error: validation failed for "..name
				 .." with schema "..schema_name)
   assert(ZEN.OK)
   TMP.valid = true
   ZEN:ftrace("validation passed for "..name.. " with schema "..schema_name)
end

function ZEN:validate_recur(obj, name)
   ZEN.assert(name, "ZEN:validate_recur error: schema name is nil")
   ZEN.assert(obj, "ZEN:validate_recur error: object is nil")
   local s = ZEN.schemas[name]
   ZEN.assert(s, "ZEN:validate_recur error: schema not found: "..name)
   ZEN.assert(type(s) == 'function', "ZEN:validate_recur error: schema is not a function: "..name)
   ZEN:ftrace("validate_recur "..name)
   local res = s(obj)
   ZEN.assert(res, "Schema validation failed: "..name)
   return(res)
end

function ZEN:ack_table(key,val)
   ZEN.assert(TMP.valid, "No valid object found in TMP")
   ZEN.assert(type(key) == 'string',"ZEN:table_add arg #1 is not a string")
   ZEN.assert(type(val) == 'string',"ZEN:table_add arg #2 is not a string")
   if not ACK[key] then ACK[key] = { } end
   ACK[key][val] = TMP.data
end

---
-- Final step inside the <b>Given</b> block towards the <b>When</b>:
-- pass on a data structure into the ACK memory space, ready for
-- processing.  It requires the data to be present in TMP[name] and
-- typically follows a @{pick}. In some restricted cases it is used
-- inside a <b>When</b> block following the inline insertion of data
-- from zencode.
--
-- @function ZEN:ack(name)
-- @param name string key of the data object in TMP[name]
function ZEN:ack(name)
   ZEN.assert(TMP.data and TMP.valid, "No valid object found: ".. name)
   assert(ZEN.OK)
   local t = type(ACK[name])
   if not ACK[name] then -- assign in ACK the single object
	  ACK[name] = TMP.data
	  goto done
   end
   -- ACK[name] already holds an object
   -- not a table?
   if t ~= 'table' then -- convert single object to array
	  ACK[name] = { ACK[name] }
	  table.insert(ACK[name], TMP.data)
	  goto done
   end
   -- it is a table already
   if isarray(ACK[name]) then -- plain array
	  table.insert(ACK[name], TMP.data)
	  goto done
   else -- associative map
	  table.insert(ACK[name], TMP.data) -- TODO: associative map insertion
	  goto done
   end
   ::done::
   assert(ZEN.OK)
end

function ZEN:ackmy(name, object)
   local obj = object or TMP.data
   ZEN:trace("f   pushmy() "..name.." "..type(obj))
   ZEN.assert(WHO, "No identity specified")
   ZEN.assert(obj, "Object not found: ".. name)
   local me = WHO
   if not ACK[me] then ACK[me] = { } end
   ACK[me][name] = obj
   assert(ZEN.OK)
end

--- When block (ACK read-write memory)
-- @section When

---
-- Draft a new text made of a simple string: convert it to @{OCTET}
-- and append it to ACK.draft.
--
-- @function ZEN:draft(string)
-- @param string any string to be appended as draft
function ZEN:draft(s)
   if s then
	  ZEN.assert(type(s) == "string", "Provided draft is not a string")
	  if not ACK.draft then
		 ACK.draft = str(s)
	  else
		 ACK.draft = ACK.draft .. str(s)
	  end
   else -- no arg: sanity checks
	  ZEN.assert(ACK.draft, "No draft found in ACK.draft")
   end
   assert(ZEN.OK)
end


---
-- Compare equality of two data objects (TODO: octet, ECP, etc.)
-- @function ZEN:eq(first, second)

---
-- Check that the first object is greater than the second (TODO)
-- @function ZEN:gt(first, second)

---
-- Check that the first object is lesser than the second (TODO)
-- @function ZEN:lt(first, second)


--- Then block (OUT write-only memory)
-- @section Then

---
-- Move a generic data structure from ACK to OUT memory space, ready
-- for its final JSON encoding and print out.
-- @function ZEN:out(name)

---
-- Move 'my own' data structure from ACK to OUT.whoami memory space,
-- ready for its final JSON encoding and print out.
-- @function ZEN:outmy(name)

---
-- Convert a data object to the desired format (argument name provided
-- as string), or use CONF.encoding when called without argument
--
-- @function ZEN:export(object, format)
-- @param object data element to be converted
-- @param format pointer to a converter function
-- @return object converted to format
local function export_arr(object, format)
   ZEN.assert(iszen(type(object)), "ZEN:export called on a ".. type(object))
   local conv_f = nil
   local ft = type(format)
   if format and ft == 'function' then conv_f = format goto ok end
   if format and ft == 'string' then conv_f = get_encoding(format).fun goto ok end
   conv_f = CONF.output.encoding.fun -- fallback to configured conversion function
   ::ok::
   ZEN.assert(type(conv_f) == 'function' , "ZEN:export conversion function not configured")
   return conv_f(object) -- TODO: protected call
end
function ZEN:export(object, format)
   -- CONF { encoding = <function 1>,
   --        encoding_prefix = "u64"  }
   ZEN.assert(object, "ZEN:export object not found")
   if type(object) == 'table' then
	  local tres = { }
	  for k,v in ipairs(object) do -- only flat tables support recursion
		 table.insert(tres, export_arr(v, format))
	  end
	  return tres
   end
   return export_arr(object, format)
end

local function pfx(o) return string.sub(o,1,3) end
local function buf(o) return string.sub(o,5) end

---
-- Import a generic data element from the tagged format, or use
-- CONF.encoding
--
-- @function ZEN:import(object)
-- @param object data element to be read
-- @param fun function to be used for conversion
-- @return object read
function ZEN:import(object, fun)
   ZEN.assert(object, "ZEN:import object is nil")
   local t = type(object)
   if iszen(t) then
      warn("ZEN:import object already converted to "..t)
      return t
   end
   -- ZEN.assert(t ~= 'table', "ZEN:import table is impossible: object needs to be 'valid'")
   -- ZEN.assert(t == 'string', "ZEN:import object is not a string: "..t)
   if t == 'table' then
	  return object
   elseif fun then
	  return(fun(object))
   else
	  return(CONF.input.encoding.fun(object))
   end
   return nil
end


-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2020 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- debug functions
local function debug_traceback()
   I.print(ZEN_traceback)
end

local function debug_heap_dump()
   I.print(HEAP)
end

local function debug_heap_schema()
   -- print only keys without values
end

-- local function debug_obj_dump()
-- local function debug_obj_schema()

Given("debug", function() ZEN.debug() end)
When("debug",  function() ZEN.debug() end)
Then("debug",  function() ZEN.debug() end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2020 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- Decentralized Privacy-Preserving Proximity Tracing scenarion in Zencode

SHA256 = HASH.new('sha256')

-- ZEN.add_schema({
-- 	  -- secret_day_key = function(obj)
-- 	  -- 	 ZEN.assert(#obj == 32, "Secret day key has wrong size (not 32 bytes / 256 bits)")
-- 	  -- 	 return obj
-- 	  -- end
-- 	  -- TODO:
-- 	  -- list of infected (array of 32 byte random hashes)
-- 	  -- ephemeral ids (array of 16 byte AES-GCM checksums)
-- })

When("I renew the secret day key to a new day", function()
		ZEN.assert(ACK.secret_day_key, "Secret day key not found")
		local sk = SHA256:process(ACK.secret_day_key)
		ZEN.assert(sk, "Error renewing secret day key (SHA256)")
		ACK.secret_day_key = sk
end)

When("I create the ephemeral ids for today", function()
		ZEN.assert(ACK.secret_day_key, "Secret day key not found")
		ZEN.assert(ACK.broadcast_key, "Broadcast key not found")
		ZEN.assert(type(ACK.epoch) == 'number', "Epoch length (minutes) not found")
		local PRF = SHA256:hmac(ACK.secret_day_key, ACK.broadcast_key)
		local epd = (24*60)/ACK.epoch -- num epochs per day
		local zero = OCTET.new(epd*16):zero() -- 0 byte buffer
		ACK.ephemeral_ids = { }
		for i = 0,epd,1 do
		   local PRG = AES.ctr(PRF, zero, O.from_number(i))
		   local l,r = OCTET.chop(PRG,16)
		   table.insert(ACK.ephemeral_ids, l)
		end
end)

When("I create the proximity tracing of infected ids", function()
		ZEN.assert(type(ACK.epoch) == 'number', "Number of moments not found")
		ZEN.assert(type(ACK.list_of_infected) == 'table', "List of infected not found")
		ZEN.assert(type(ACK.ephemeral_ids) == 'table', "List of ephemeral ids not found")
		ZEN.assert(ACK.broadcast_key, "Broadcast key not found")
		ACK.proximity_tracing = { }
		local epd = (24*60)/ACK.epoch -- num epochs per day
		local zero = OCTET.new(epd*16):zero() -- 0 byte buffer
		for n,sk in ipairs(ACK.list_of_infected) do
		   local PRF = SHA256:hmac(sk, ACK.broadcast_key)
		   for i = 0,epd,1 do
			  local PRG = OCTET.chop( AES.ctr(PRF, zero, O.from_number(i)), 16)
			  for nn,eph in next, ACK.ephemeral_ids, nil do
				 if eph == PRG then
					table.insert(ACK.proximity_tracing, sk)
				 end
			  end
		   end
		end
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- Zencode for Implicit Certificates (ECQV)

-- stateful globals
-- TODO: use finite state machine
whoami = nil
declared = nil
certificate = nil
declaration = nil
whois = nil
authority = nil

function f_certhash(t)
   ZEN.assert(validate(t,schemas['certificate_hash']),
		  "Invalid input to generate a certificate hash")
   return INT.new(sha256(OCTET.serialize(t)))
end

When("I issue my implicit certificate request ''", function(decl)
		local certreq = ZEN.keygen()
		data = data or ZEN.data.load()
		ZEN.data.add(data, decl.."_public",
					{ schema = "declaration",
					  from = whoami,
					  to = authority,
					  statement = declared,
					  public = hex(certreq.public) })
		ZEN.data.add(data, decl.."_keypair",
					{ schema = "keypair",
					  public = hex(certreq.public),
					  private = hex(certreq.private) })
end)
Then("print my ''", function (what)
		ZEN.assert(_G[what], "Cannot print, data not found: "..what)
		local t = type(_G[what])
		if t == "table" then write_json(_G[what])
		elseif iszen(t) or t == "string" then
		   print(_G[what])
		else
		   error("Cannot print '"..what.."' data type: "..t)
		end
end)

When("I issue an implicit certificate for ''", function(decl)
		init_keyring(whoami)
		data = data or ZEN.data.load()
		-- read global states set before
		local declaration = data[decl]
		local certkey = ZEN.keygen()
		local certreq = ECP.new(declaration.public)
		-- generate the certificate
		local certpub = certreq + certkey.public
		local certhash = f_certhash({ public    = certpub,
									  requester = declaration.from,
									  statement = declaration.statement,
									  certifier = whoami })
		local certpriv = (certhash * certkey.private + keyring[keypair].private)
		-- format the certificate
		local certificate = { }
		ZEN.data.add(data, 'certificate_public',
					{ schema = 'certificate',
					  public  = hex(certpub),
					  hash    = hex(certhash),
					  authkey = keyring[keypair].public,
					  from = whoami })
		ZEN.data.add(data, 'certificate_private',
					{ schema = 'certificate',
					  public  = hex(certpub),
					  private = hex(certpriv),
					  hash    = hex(certhash),
					  authkey = keyring[keypair].public,
					  from = whoami })
end)

-- save
-- keypair contains declaration's keys
When("I verify the implicit certificate ''", function(verif)
		-- we only know how to verify declarations with certificates
		-- ZEN.assert(obj == "declaration" and verif == "certificate",
		-- 	   "Cannot verify "..obj.." with "..verif)
		init_keyring('declaration_keypair')
		data = data or ZEN.data.load()
		certificate = data[verif]
		ZEN.assert(validate(certificate,schemas['certificate']),
				   "Invalid implicit certificate: "..verif)
		-- explicit conversions
		local v = { certhash = INT.new(certificate.hash),
					declpriv = INT.new(keyring[keypair].private),
					certpriv = INT.new(certificate.private),
					capub    = ECP.new(certificate.authkey),
					certpub  = ECP.new(certificate.public)  }
		v.checkpriv = (v.certhash * v.declpriv + v.certpriv) % order
		v.checkpub  =  v.certpub  * v.certhash + v.capub
		ZEN.assert(v.checkpub == (G * v.checkpriv),
			   "Verification failed: "..verif.." is not valid:\n"..DATA)
		-- publish signed declaration
		ZEN.data.add(data,'declaration', {
						hash = certificate.hash,
						authkey = certificate.authkey,
						certificate = certificate.public })
end)

When("I use the '' to encrypt ''", function(what,content)
		local cipher = { iv = random:octet(16) }
		if what == "certificate" then
		   local CERThash = f_certhash({ public    = certificate.public,
										 requester = whois,
										 statement = declared,
										 certifier = certificate.from })
		   -- TODO: correct hash comparison
		   -- I.print(certificate.hash)
		   -- I.print(CERThash)
		   -- I.print(type(hex(certificate.hash)))
		   -- I.print(type(CERThash:octet()))
--		   ZEN.assert(certificate.hash == CERThash, "Incorrect certificate hash")
		   local CERTpublic = ECP.new(certificate.public) * CERThash + ECP.new(certificate.authkey)
		   -- calculate shared session key
		   session_raw = ( INT.new(keypair.private) % order) * CERTpublic
		   session = ECDH.kdf2(HASH.new('sha256'),session_raw) -- ,random:octet(64),KDF_rounds,32)
		end
		-- header is in the ciphertext for increased privacy (no metadata)
		local text = str(MSG.pack({ from = whoami,
									pubkey = keypair.public,
									text = content }))

		cipher.text,cipher.checksum =
		   ECDH.aesgcm_encrypt(session, text, random:octet(16), str("Zencode"))

		cipher = map(cipher,hex)
		cipher.schema = "ciphertext"
		ZEN.data.conjoin(data,"message","ciphertext",cipher)
		-- cipher.header = header -- hex(header)
		-- _G['message'] = I.spy(cipher)
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2019-2020 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.


ZEN.eval_cache = { }
-- http://www.lua.org/manual/5.3/manual.html#pdf-load
function ZEN.eval_condition(cond, env)
   local lcond = string.gsub(cond,'_', ' ')
   local funcond = "-- .."..lcond..[[
local x=_ENV.x
local y=_ENV.y
if ]]..lcond..[[ then
return true
else return false
end]]
   -- cache the assert
   if not ZEN.eval_cache[cond] then
	  ZEN.assert(load(funcond, 'condition', 't'), "Invalid condition: "..lcond)
	  ZEN.eval_cache[cond] = funcond
   else
	  funcond = ZEN.eval_cache[cond]
   end
   if env then -- fill environment
	  env.sha256 = sha256
	  env.ECDH = ECDH
	  env.ECP = ECP
	  env.ECP2 = ECP2
	  env.PAIR = PAIR
	  env.INT = INT
	  env.OCTET = OCTET
	  return(load(funcond,'condition','t',env)())
   else return nil end
end

function ZEN.eval_function(fun, env)
   local lfun = string.gsub(fun,'_', ' ')
   local funexe = [[-- "]]..lfun..[[
local x=_ENV.x
return ]]..lfun
   -- cache the assert
   if not ZEN.eval_cache[fun] then
	  ZEN.assert(load(funexe, 'condition', 't'), "Invalid condition: "..lfun)
	  ZEN.eval_cache[fun] = funexe
   else
	  funexe = ZEN.eval_cache[fun]
   end
   if env then -- fill environment
	  env.sha256 = sha256
	  env.sha512 = sha512
	  env.ECDH = ECDH
	  env.ECP = ECP
	  env.ECP2 = ECP2
	  env.PAIR = PAIR
	  env.INT = INT
	  env.OCTET = OCTET
	  return(load(funexe,'function','t',env)())
   else return nil end
end

When("for each x in '' y in '' is true ''", function(X, Y, cond)
		ZEN.assert(isarray(ACK[X]), "Array X not found: "..X)
		ZEN.assert(isarray(ACK[Y]), "Array Y not found: "..Y)
		ZEN.eval_condition(cond) -- check
		local c = 0
		for k,x in sort_ipairs(ACK[X]) do
		   c = c + 1
		   local y = ACK[Y][k]
		   -- local fun = load(asscond, 'condition', 't', {y=y,x=x,ECP=ECP})
		   ZEN.assert(ZEN.eval_condition(cond, {y=y,x=x}),
					  "Checked condition failed on arr["..c.."]: " ..cond)
		end
end)
When("for each x in '' create the array using ''", function(arr,fun)
		ZEN.assert(isarray(ACK[arr]), "Array not found: "..arr)
		ZEN.eval_function(fun) -- check
		local c = 0
		ACK.array = { }
		for k,v in sort_ipairs(ACK[arr]) do
		   c = c + 1
		   table.insert(ACK.array, ZEN.eval_function(fun,{x=v}))
		end
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.


-- GIVEN
local function gc()
   TMP = { }
   collectgarbage'collect'
end

Given("nothing", function() ZEN.assert(not DATA and not KEYS, "Unused data passed as input") end)
Given("all data", function()
		 ZEN.assert(CONF.input.encoding.fun, "No input encoding rule found")
		 local fun = CONF.input.encoding.fun
		 ZEN:assert(luatype(fun) == 'function', "Conversion is not a valid function")
		 local function conv(intab)
			for k, v in next,intab,nil do
			   if luatype(v) == "table" then
				  ACK[k] = conv(v) -- was just table.copy
			   else
				  ACK[k] = fun(v)
			   end
			end
		 end
		 conv(IN)
end)
-- TODO: Given all valid data
-- convert and import data only when is known by schema and passes validation
-- ignore all other data structures that are not known by schema or don't pass validation

Given("I introduce myself as ''", function(name) ZEN:Iam(name) end)
Given("I am known as ''", function(name) ZEN:Iam(name) end)
Given("I am ''", function(name) ZEN:Iam(name) end)

Given("I have a ''", function(name)
		 ZEN:pick(name)
		 TMP.valid = true
		 ZEN:ack(name)
		 gc()
end)
Given("I have my ''", function(name)
		 ZEN.assert(WHO, "No identity specified, use: Given I am ...")
		 ZEN:pickin(WHO, name)
		 TMP.valid = true
		 ZEN:ack(name)
		 gc()
end)

Given("I have my valid ''", function(name)
		 ZEN.assert(WHO, "No identity specified, use: Given I am ...")
		 ZEN:pickin(WHO, name)
		 ZEN:validate(name)
		 ZEN:ack(name)
		 gc()
end)

Given("I have a valid ''", function(name)
		 ZEN:pick(name)
		 ZEN:validate(name)
		 ZEN:ack(name)
		 gc()
end)
Given("the '' is valid", function(name)
		 ZEN:pick(name)
		 ZEN:validate(name)
		 ZEN:ack(name)
		 gc()
end)

Given("I have a '' inside ''", function(n, s)
		 ZEN:pickin(s, n)
		 TMP.valid = true
		 ZEN:ack(n) -- save it in ACK.n
		 gc()
end)
Given("I have inside '' a ''", function(s, n)
		 ZEN:pickin(s, n)
		 TMP.valid = true
		 ZEN:ack(s) -- save it in ACK.s.n
		 gc()
end)


Given("I have inside '' a valid ''", function(s, n)
		 ZEN:pickin(s, n)
		 ZEN:validate(n)
		 ZEN:ack(s) -- save it in ACK.s.n
		 gc()
end)
Given("I have a valid '' inside ''", function(n, s)
		 ZEN:pickin(s, n)
		 ZEN:validate(n)
		 ZEN:ack(n) -- save it in ACK.n
		 gc()
end)

-- public keys for keyring arrays
Given("I have a valid '' from ''", function(n, s)
		 ZEN:pickin(s, n)
		 ZEN:validate(n)
		 ZEN:ack_table(n, s)
		 gc()
end)

ZEN.add_schema({
	  array = function(obj)
		 ZEN.assert( isarray(obj) , "Not a valid array")
		 local fun = CONF.input.encoding.fun
		 ZEN.assert( luatype(fun) == 'function', "Conversion is not a valid function")
		 local _t = { }
		 for k,v in ipairs(obj) do
			table.insert(_t, fun(v))
		 end
		 return _t
	  end,
	  array_string = function(obj)
		 ZEN.assert( isarray(obj) , "Not a valid array")
		 local _t = { }
		 for k,v in ipairs(obj) do
			table.insert(_t, OCTET.from_string(v))
		 end
		 return _t
	  end,
	  array_ecp = function(obj)
		 ZEN.assert( isarray(obj) , "Not a valid array")
		 local fun = CONF.input.encoding.fun
		 ZEN.assert( luatype(fun) == 'function', "Conversion is not a valid function")
		 local _t = { }
		 for k,v in ipairs(obj) do
			table.insert(_t, ECP.new(fun(v)))
		 end
		 return _t
	  end

})

Given("I have a valid array in ''", function(a)
		 local got -- local impl of ZEN:pick for array
		 got = IN.KEYS[a] or IN[a]
		 ZEN.assert(got, "Cannot find '"..a.."' anywhere")
		 ZEN.assert(type(got) == 'table', "Object is not an array: "..a)
		 TMP = { root = nil,
				 data = got,
				 valid = false,
				 schema = 'array' }
		 assert(ZEN.OK)
		 ZEN:validate(a,'array')
		 ZEN:ack(a)
		 gc()
end)

Given("I have a valid array of '' in ''", function(t,a)
		 local got -- local impl of ZEN:pick for array
		 got = IN.KEYS[a] or IN[a]
		 ZEN.assert(got, "Cannot find '"..a.."' anywhere")
		 ZEN.assert(type(got) == 'table', "Object is not an array: "..a)
		 TMP = { root = nil,
				 data = got,
				 valid = false,
				 schema = 'array' }
		 assert(ZEN.OK)
		 ZEN:validate(a,'array_'..t:lower())
		 ZEN:ack(a)
		 gc()
end)

Given("I have a valid number in ''", function(n)
		 local num = tonumber(IN[n])
		 ZEN.assert(num, "Invalid number in "..n..": "..IN[n])
		 TMP = { root = nil,
				 data = num,
				 valid = type(num) == 'number',
				 schema = nil }
		 ZEN:ack(n)
		 gc()
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

-- make sure relevant defaults are there
CONF.encoding = CONF.encoding or url64
CONF.encoding_prefix = CONF.encoding_prefix or 'u64'

ZEN.add_schema({
	  -- keypair (ECDH)
	  public_key = function(obj)
		 local o = obj.public_key or obj -- fix recursive schema check
		 if type(o) == "string" then o = ZEN:import(o) end
		 ZEN.assert(ECDH.pubcheck(o),
					"Public key is not a valid point on curve")
		 return o
	  end,
      keypair = function(obj)
         return { public_key  = ZEN:validate_recur(obj, 'public_key'),
                  private_key = ZEN.get(obj, 'private_key') }
	  end,
	  secret_message = function(obj)
		 return { checksum = ZEN.get(obj, 'checksum'),
				  header   = ZEN.get(obj, 'header'),
				  iv       = ZEN.get(obj, 'iv'),
				  text     = ZEN.get(obj, 'text') }
	  end,
	  signature = function(obj)
		 return { r = ZEN.get(obj, 'r', INT.new),
				  s = ZEN.get(obj, 's', INT.new) }
--				  text = ZEN.get(obj, 'text') }
	  end
})

-- generate keypair
local function f_keygen()
   local kp
   kp = ECDH.keygen()
   ZEN:pick('keypair', { public_key = kp.public,
						 private_key = kp.private })
   ZEN:validate('keypair')
   ZEN:ack('keypair')
end
When("I create the keypair", f_keygen)

-- encrypt with a header and secret
When("I encrypt the secret message '' with ''", function(msg, sec)
		ZEN.assert(ACK[msg], "Data to encrypt not found: message")
		ZEN.assert(ACK[sec], "Secret used to encrypt not found: "..sec)
		-- KDF2 sha256 on all secrets
		local secret = KDF(ACK[sec])
		ACK.secret_message = { header = ACK.header or 'empty',
							   iv = O.random(32) }
		ACK.secret_message.text, ACK.secret_message.checksum =
		   ECDH.aead_encrypt(secret, ACK[msg],
							 ACK.secret_message.iv,
							 ACK.secret_message.header)
end)

-- decrypt with a secret
When("I decrypt the secret message with ''", function(sec)
		ZEN.assert(ACK[sec], "Secret used to decrypt not found: secret")
		ZEN.assert(ACK.secret_message,
				   "Secret data to decrypt not found: secret message")

        local secret = KDF(ACK[sec])
        -- KDF2 sha256 on all secrets, this way the
        -- secret is always 256 bits, safe for direct aead_decrypt
        ACK.message = { header = ACK.secret_message.header }
        ACK.message.text, ACK.checksum =
           ECDH.aead_decrypt(secret,
							 ACK.secret_message.text,
							 ACK.secret_message.iv,
							 ACK.message.header)
        ZEN.assert(ACK.checksum == ACK.secret_message.checksum,
                   "Decryption error: authentication failure, checksum mismatch")
end)

-- encrypt to a single public key
When("I encrypt the message for ''", function(_key)
		ZEN.assert(ACK.keypair, "Keys not found: keypair")
		ZEN.assert(ACK.keypair.private_key, "Private key not found in keypair")
		ZEN.assert(ACK.message, "Data to encrypt not found: message")
		ZEN.assert(type(ACK.public_key) == 'table',
				   "Public keys not found in keyring")
		ZEN.assert(ACK.public_key[_key], "Public key not found for: ".._key)
		local private = ACK.keypair.private_key
		local key = ECDH.session(ACK.keypair.private_key, ACK.public_key[_key])
		ACK.secret_message = { header = ACK.header or 'empty',
							   iv = O.random(32) }
		ACK.secret_message.text,
		ACK.secret_message.checksum =
		   ECDH.aead_encrypt(key,
							 ACK.message,
							 ACK.secret_message.iv,
							 ACK.secret_message.header)
end)


When("I decrypt the secret message from ''", function(_key)
		ZEN.assert(ACK.keypair, "Keyring not found")
		ZEN.assert(ACK.keypair.private_key, "Private key not found in keyring")
		ZEN.assert(ACK.secret_message, "Data to decrypt not found: secret_message")
		ZEN.assert(ACK.public_key[_key],
				   "Key to decrypt not found: public key[".._key.."])")
		local session = ECDH.session(ACK.keypair.private_key, ACK.public_key[_key])
		ACK.message, checksum = ECDH.aead_decrypt(session,
												  ACK.secret_message.text,
												  ACK.secret_message.iv,
												  ACK.secret_message.header)
		ZEN.assert(checksum == ACK.secret_message.checksum,
				   "Failed verification of integrity for secret message")
end)

-- sign a message and verify
When("I create the signature of ''", function(doc)
		ZEN.assert(ACK.keypair, "Keyring not found")
		ZEN.assert(ACK.keypair.private_key, "Private key not found in keyring")
		local obj = ACK[doc]
		ZEN.assert(obj, "Object not found: "..doc)
		local t = type(obj)
		if t == 'table' then
		   local s = ECDH.sign(ACK.keypair.private_key, OCTET.serialize(obj))
		   ACK[doc].signature = s
		else
		   ACK.signature = ECDH.sign(ACK.keypair.private_key, obj)
		end
		-- include contextual information
end)

When("I verify the '' is signed by ''", function(msg, by)
		ZEN.assert(ACK.public_key[by], "Public key by "..by.." not found")
		local obj = ACK[msg]
		ZEN.assert(obj, "Object not found: "..msg)
		local t = type(obj)
		local sign
		if t == 'table' then
		   sign = obj.signature
		   ZEN.assert(sign, "Signature by "..by.." not found")
		   obj.signature = nil
		   ZEN.assert(ECDH.verify(ACK.public_key[by], OCTET.serialize(obj), sign),
					  "The signature is not authentic")
		else
		   sign = ACK.signature[by]
		   ZEN.assert(sign, "Signature by "..by.." not found")
		   ZEN.assert(ECDH.verify(ACK.public_key[by], obj, sign),
					  "The signature is not authentic")
		end
end)
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

--- THEN

Then("print ''", function(v)
		table.insert(OUT, v) -- raw string
end)

Then("print '' ''", function(k,v)
		OUT[k] = v -- ZEN:import(v, false)
end)


Then("print '' '' as ''", function(k,v,s)
		OUT[k] = ZEN:export( ZEN:import(v, input_encoding(s).fun), s)
end)

Then("print all data", function()
		OUT = ACK
end)
Then("print my data", function() ZEN:Iam() -- sanity checks
		OUT[WHO] = ACK
end)
Then("print all my data", function() ZEN:Iam() 
		OUT[WHO] = ACK
end)
Then("print my ''", function(obj) ZEN:Iam()
		ZEN.assert(ACK[obj], "Data not found in ACK: "..obj)
		if not OUT[WHO] then OUT[WHO] = { } end
		OUT[WHO][obj] = ACK[obj]
end)

Then("print as '' my ''", function(conv,obj)		ZEN:Iam()
		ZEN.assert(ACK[obj], "My data: "..obj.." not found to print: "..conv)
		if not OUT[WHO] then OUT[WHO] = { } end
		OUT[WHO][obj] = ZEN:export(ACK[obj], conv)
end)
Then("print my '' as ''", function(obj,conv)		ZEN:Iam()
		ZEN.assert(ACK[obj], "My data: "..obj.." not found to print: "..conv)
		if not OUT[WHO] then OUT[WHO] = { } end
		OUT[WHO][obj] = ZEN:export(ACK[obj], conv)
end)

Then("print the ''", function(key)
		if not OUT[key] then
		   ZEN.assert(ACK[key], "Data to print not found: "..key)
		   OUT[key] = ACK[key]
		end
end)

Then("print as '' the ''", function(conv, obj) OUT[obj] = ZEN:export(ACK[obj], conv) end)
Then("print the '' as ''", function(obj, conv) OUT[obj] = ZEN:export(ACK[obj], conv) end)

Then("print as '' the '' inside ''", function(conv, obj, section)
		local src = ACK[section][obj]
		ZEN.assert(src, "Not found "..obj.." inside "..section)
		OUT[obj] = ZEN:export(src, conv)
end)
Then("print the '' as '' inside ''", function(obj, conv, section)
		local src = ACK[section][obj]
		ZEN.assert(src, "Not found "..obj.." inside "..section)
		OUT[obj] = ZEN:export(src, conv)
end)

-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.


--- WHEN

When("I append '' to ''", function(content, dest)
		ZEN.assert(not ZEN.schemas[dest], "When denied, schema collision detected: "..dest)
		ACK[dest] = ACK[dest] .. ZEN:import(content)
end)
When("I append '' to '' formatted as ''", function(content, dest, format)
		ZEN.assert(not ZEN.schemas[dest], "When denied, schema collision detected: "..dest)
		ACK[dest] = ACK[dest] .. ZEN:import(content, input_encoding(format).fun) -- add prefix
end)

-- simplified exception for I write: import encoding from_string
When("I write string '' in ''", function(content, dest)
		ZEN.assert(not ZEN.schemas[dest], "When denied, schema collision detected: "..dest)
		ACK[dest] = O.from_string(content)
end)
When("I write number '' in ''", function(content, dest)
		ZEN.assert(not ZEN.schemas[dest], "When denied, schema collision detected: "..dest)
		-- TODO: detect number base 10
		ACK[dest] = tonumber(content, 10)
end)

When("I set '' to '' as ''", function(dest, content, format)
		ZEN.assert(not ZEN.schemas[dest], "When denied, schema collision detected: "..dest)
		ACK[dest] = ZEN:import(content, input_encoding(format).fun)
end)
When("I create a random ''", function(s)
		ZEN.assert(not ZEN.schemas[s], "When denied, schema collision detected: "..s)
		ACK[s] = OCTET.random(64) -- TODO: right now hardcoded 256 bit random secrets
end)

-- generic comparison using overloaded __eq on any value
When("I verify '' is equal to ''", function(l,r)
		ZEN.assert(ACK[l] == ACK[r],
				   "When comparison failed: objects are not equal: "
					  ..l.." == "..r)
end)

-- hashing single strings
When("I create the hash of ''", function(s)
		-- TODO: hash an array
		local src = ACK[s]
		ZEN.assert(src, "Object not found: "..s)
		ACK.hash = sha256(src)
end)

When("I create the hash of '' using ''", function(s,h)
		local src = ACK[s]
		ZEN.assert(src, "Object not found: "..s)
		if strcasecmp(h,'sha256') then		   
		   ACK.hash = sha256(src)
		elseif strcasecmp(h,'sha512') then
		   ACK.hash = sha512(src)
		end
		ZEN.assert(ACK.hash, "Invalid hash: "..h)
end)

-- numericals
When("I set '' to '' base ''", function(dest, content, base)
		ZEN.assert(not ACK[dest], "When denied, schema collision detected: "..dest)
		local bas = tonumber(base)
		ZEN.assert(bas, "Invalid numerical conversion for base: "..base)
		local num = tonumber(content,bas)
		ZEN.assert(num, "Invalid numerical conversion for value: "..content)
		ACK[dest] = num
end)

-- check a tuple of numbers before comparison, convert from octet if necessary
local function numcheck(left, right)
   local al, ar
   ZEN.assert(left, "numcheck left object not found")
   if type(left) == "zenroom.octet" then al = BIG.new(left):integer()
   else al = left end
   local l = tonumber(al)
   ZEN.assert(l, "Invalid numcheck left argument: "..type(left))

   ZEN.assert(right, "numcheck right object not found")
   if type(right) == "zenroom.octet" then ar = BIG.new(right):integer()
   else ar = right end
   local r = tonumber(ar)
   ZEN.assert(r, "Invalid numerical in right argument: "..type(right))
   return l, r
end
When("number '' is less than ''", function(left, right)
		local l, r = numcheck(ACK[left], ACK[right])
		ZEN.assert(l < r, "Failed comparison: "..l.." is not less than "..r)
end)
When("number '' is less or equal than ''", function(left, right)
		local l, r = numcheck(ACK[left], ACK[right])
		ZEN.assert(l <= r, "Failed comparison: "..l.." is not less or equal than "..r)
end)
When("number '' is more than ''", function(left, right)
		local l, r = numcheck(ACK[left], ACK[right])
		ZEN.assert(l > r, "Failed comparison: "..l.." is not more than "..r)
end)
When("number '' is more or equal than ''", function(left, right)
		local l, r = numcheck(ACK[left], ACK[right])
		ZEN.assert(l >= r, "Failed comparison: "..l.." is not more or equal than "..r)
end)
When("'' in '' is more than '' in ''", function(ele, left, ere, right)
		ZEN.assert(ACK[left], "Object not found: "..left)
		local lo = ACK[left][ele]
		ZEN.assert(lo, "Number not found: "..left.."."..ele)
		ZEN.assert(ACK[right], "Object not found: "..right)
		local ro = ACK[right][ere]
		ZEN.assert(ro, "Number not found: "..right.."."..ere)
		local l, r = numcheck(lo, ro)
		ZEN.assert(l > r, "Failed comparison: "..left.."."..ele..
					  " is not more than "..right.."."..ere)
end)

-- random and hashing operations
When("I create the random object of '' bits", function(n)
   local bits = tonumber(n)
   ZEN.assert(bits, "Invalid number of bits: "..n)
   ACK.random_object = OCTET.random( math.ceil(bits/8) )
end)

-- array operations
When("I create the array of '' random objects", function(s)
		ACK.array = { }
		for i = s,1,-1 do
		   table.insert(ACK.array,OCTET.random(64))
		end
end)

When("I create the array of '' random objects of '' bits", function(s, bits)
		ACK.array = { }
		local bytes = math.ceil(bits/8)
		for i = s,1,-1 do
		   table.insert(ACK.array,OCTET.random(bytes))
		end
end)

When("I create the array of '' random curve points", function(s)
		ACK.array = { }
		for i = s,1,-1 do
		   table.insert(ACK.array,ECP.random())
		end
end)


When("I create the aggregation of ''", function(arr)
		local A = ACK[arr]
		ZEN.assert(A, "Object not found: "..arr)
		local count = isarray(A)
		ZEN.assert( count > 0, "Object is not an array: "..arr)
		if type(A[1]) == 'zenroom.ecp' then -- TODO: check all elements
		   ACK.aggregation = ECP.generator()
		   for k,v in next,A,nil do
			  if not ACK.aggregation then ACK.aggregation = v
			  else ACK.aggregation = ACK.aggregation + v end
		   end
		else -- TODO: more aggregators for INT and ECP2
		   error("Unknown aggregation for type: "..type(A[1]))
		end
end)

When("I create the hash to point '' of each object in ''", function(what, arr)
		local F = _G[what]
		ZEN.assert(luatype(F.hashtopoint) == 'function',
				   "Hash type "..what.." is invalid (no hashtopoint)")
        local A = ACK[arr]
        ZEN.assert(A, "Object not found: "..arr)
        local count = isarray(A)
        ZEN.assert( count > 0, "Object is not an array: "..arr)
        ACK.hashes = { }
        for k,v in sort_ipairs(A) do
		   ACK.hashes[k] = F.hashtopoint(v)
        end
end)

When("I rename the '' to ''", function(old,new)
		ZEN.assert(ACK[old], "Object not found: "..old)
		ACK[new] = ACK[old]
		ACK[old] = nil
end)

When("I pick the random object in ''", function(arr)
		local A = ACK[arr]
		ZEN.assert(A, "Object not found: "..arr)
		local count = isarray(A)
		ZEN.assert( count > 0, "Object is not an array: "..arr)
		local r = random_int16() % count
		ACK.random_object = A[r]
end)

When("I randomize the '' array", function(arr)
		local A = ACK[arr]
		ZEN.assert(A, "Object not found: "..arr)
		local count = isarray(A)
		ZEN.assert( count > 0, "Object is not an array: "..arr)
		local res = { }
		for i = count,2,-1 do
		   local r = (random_int16() % (i-1))+1
		   table.insert(res,A[r]) -- limit 16bit lenght for arrays
		   table.remove(A, r)
		end
		table.insert(res,A[1])
		ACK[arr] = res
end)

When("I remove the '' from ''", function(ele,arr)
		local E = ACK[ele]
		ZEN.assert(E, "Element not found: "..ele)
		local A = ACK[arr]
		ZEN.assert(A, "Array not found: "..arr)
		ZEN.assert( isarray(A) > 0, "Object is not an array: "..arr)
		local O = { }
		for k,v in next,A,nil do
		   if v ~= E then table.insert(O,v) end
		end
		ACK[arr] = O
end)

When("I insert the '' in ''", function(ele,arr)
		ZEN.assert(ACK[ele], "Element not found: "..ele)
		ZEN.assert(ACK[arr], "Array not found: "..arr)
		table.insert(ACK[arr], ACK[ele])
end)

When("the '' is not found in ''", function(ele, arr)
		ZEN.assert(ACK[ele], "Element not found: "..ele)
		ZEN.assert(ACK[arr], "Array not found: "..arr)
		for k,v in next,ACK[arr],nil do
		   ZEN.assert(v ~= ACK[ele], "Element '"..ele.."' is contained inside array: "..arr)
		end
end)


When("the '' is found in ''", function(ele, arr)
		ZEN.assert(ACK[ele], "Element not found: "..ele)
		ZEN.assert(ACK[arr], "Array not found: "..arr)
		local found = false
		for k,v in next,ACK[arr],nil do
		   if v == ACK[ele] then found = true end
		end
		ZEN.assert(found, "Element '"..ele.."' is not found inside array: "..arr)
end)

When("I split the rightmost '' bytes of ''", function(len, src)
		local s = tonumber(len)
		ZEN.assert(s, "Invalid number arg #1: "..type(len))
		ZEN.assert(ACK[src], "Element not found: "..src)
		ZEN.assert(ACK.rightmost ~= nil, "Overwrite error: rightmost")
		local l,r = OCT.chop(ACK[src],s)
		ACK.rightmost = r
		ACK[src] = l
end)

When("I split the leftmost '' bytes of ''", function(len, src)
		local s = tonumber(len)
		ZEN.assert(s, "Invalid number arg #1: "..type(len))
		ZEN.assert(ACK[src], "Element not found: "..src)
		ZEN.assert(ACK.leftmost == nil, "Overwrite error: leftmost")
		print(#src)
		local l,r = OCTET.chop(ACK[src],s)
		ACK.leftmost = l
		ACK[src] = r
end)

-- TODO:
-- When("I set '' as '' with ''", function(dest, format, content) end)
-- When("I append '' as '' to ''", function(content, format, dest) end)
-- When("I write '' as '' in ''", function(content, dest) end)
-- implicit conversion as string
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local aes = require'aes'
return aes
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2020 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

function zencode_iscomment(b)
   local x = string.char(b:byte(1))
   if x == '#' then
	  return true
   else return false
end end
function zencode_isempty(b)
   if b == nil or b == '' then
	   return true
   else return false
end end
-- returns an iterator for newline termination
function zencode_newline_iter(text)
   s = trim(text) -- implemented in zen_io.c
   if s:sub(-1)~="\n" then s=s.."\n" end
   return s:gmatch("(.-)\n") -- iterators return functions
end

function set_sentence(self, event, from, to, ctx)
   local reg = ctx.Z[self.current.."_steps"]
   ctx.Z.OK = false
   ZEN.assert(reg, "Steps register not found: "..self.current.."_steps")
   for pattern,func in pairs(reg) do
	  if (type(func) ~= "function") then
		 error("Zencode function missing: "..pattern, 2)
		 return false
	  end
	  -- TODO: optimize in c
	  -- remove '' contents, lower everything, expunge prefixes
	  local tt = string.gsub(ctx.msg,"'(.-)'","''")
	  tt = string.gsub(tt:lower() ,"when " ,"", 1)
	  tt = string.gsub(tt,"then " ,"", 1)
	  tt = string.gsub(tt,"given ","", 1)
	  tt = string.gsub(tt,"and "  ,"", 1) -- TODO: expunge only first 'and'
	  tt = string.gsub(tt,"that " ,"", 1)
	  if strcasecmp(tt, pattern) then
		 local args = {} -- handle multiple arguments in same string
		 for arg in string.gmatch(ctx.msg,"'(.-)'") do
			-- xxx(2,"+arg: "..arg)
			arg = string.gsub(arg, ' ', '_')
			table.insert(args,arg)
		 end
		 ctx.Z.id = ctx.Z.id + 1
		 -- AST data prototype
		 table.insert(ctx.Z.AST,
					  { id = ctx.Z.id, -- ordered number
						args = args,  -- array of vars
						source = ctx.msg, -- source text
						section = self.current,
						hook = func       }) -- function
		 ctx.Z.OK = true
		 break
	  end
   end
   if not ctx.Z.OK and CONF.parser.strict_match then
	  print(ZEN_traceback)
   	  exitcode(1)
   	  error("Zencode pattern not found: "..ctx.msg, 2)
   	  return false
   end
end


-- TODO: investigate use of lua-faces
function set_rule(text)
   local res = false
   local rule = strtok(text.msg) -- TODO: optimise in C (see zenroom_common)
   if rule[2] == 'check' and rule[3] == 'version' and rule[4] then
	  SEMVER = require_once('semver')
	  local ver = SEMVER(rule[4])
	  if ver == VERSION then
		 act("Zencode version match: "..VERSION.original)
		 res = true
	  elseif ver < VERSION then
		 error("Zencode written for an older version: "
				 ..ver.original.." < "..VERSION.original, 2)
	  elseif ver > VERSION then
		 error("Zencode written for a newer version: "
					..ver.original.." > "..VERSION.original, 2)
	  else
		 error("Version check error: "..rule[4])
	  end
	  text.Z.checks.version = res
      -- TODO: check version of running VM
	  -- elseif rule[2] == 'load' and rule[3] then
	  --     act("zencode extension: "..rule[3])
	  --     require("zencode_"..rule[3])
   elseif rule[2] == 'input' and rule[3] then

      -- rule input encoding|format ''
      if rule[3] == 'encoding' and rule[4] then
         CONF.input.encoding = input_encoding(rule[4])
		 res = true and CONF.input.encoding
      elseif rule[3] == 'format' and rule[4] then
		 CONF.input.format = get_format(rule[4])
         res = true and CONF.input.format
	  elseif rule[3] == 'untagged' then
		 res = true
		 CONF.input.tagged = false
      end

   elseif rule[2] == 'output' and rule[3] then
      -- rule input encoding|format ''
      if rule[3] == 'encoding' then
         CONF.output.encoding = get_encoding(rule[4])
		 res = true and CONF.output.encoding
      elseif rule[3] == 'format' then
		 CONF.output.format = get_format(rule[4])
         res = true and CONF.output.format
      elseif rule[3] == 'versioning' then
		 CONF.output.versioning = true
         res = true
      elseif strcasecmp(rule[3],'ast') then
		 CONF.output.AST = true
		 res = true
	  end

   elseif rule[2] == 'unknown' and rule[3] then
	  if rule[3] == 'ignore' then
		 CONF.parser.strict_match = false
		 res = true
	  end

   elseif rule[2] == 'set' and rule[4] then

      CONF[rule[3]] = tonumber(rule[4]) or rule[4]
      res = true and CONF[rule[3]]

   end
   if not res then error("Rule invalid: "..text.msg, 3)
   else act(text.msg) end
   return res
end


return zencode_parse
local bench = { }

bench.entropy = function()
   act("Benchmark: entropy of random generators (Shannon ratios)")
   print("SEED: \t ".. RNGSEED:entropy())
   print("PRNG: \t ".. OCTET.random(256):entropy())
   -- use standard ECP size
   local s = #ECP.random():octet()
   print("OCTET: \t "..OCTET.random(s):entropy())
   print("BIG:   \t "..BIG.random():octet():entropy())
   print("ECP:   \t "..ECP.random():octet():entropy())
   print("ECP2:  \t "..ECP2.random():octet():entropy())
end

bench.random_hamming_freq = function (s, q)
   local _s = s or 97
   local _q = q or 5000
   act("Benchmark: hamming distance between random, arguments: ".._s.." ".._q)

   -- ECP coordinates are 97 bytes
   local new = O.random(_s)
   local tot = 0
   local old
   for i=_q,1,-1 do
	  old = new
	  new = O.random(_s)
	  tot = tot + O.hamming(old,new)
   end
   return tot / _q
end

bench.random_kdf = function()
   act("Benchmark: KDF2 SHA256 and SHA512 on random")
   -- KDF2 input can be any, output
   local r = O.random(64)
   HASH.kdf2(HASH.new('SHA256'),r)
   HASH.kdf2(HASH.new('SHA512'),r)
end


-- find primes
local square = {} for i=0,9 do square[i]=i*i end
local function sqrsum(n)
   local sum = 0
   while n > 0 do sum, n = sum + square[n % 10], math.floor(n / 10) end
   return sum
end
local function isHappy(n)
   while n ~= 1 and n ~= 4 do n = sqrsum(n) end
   return n == 1
end
local prime_numbers = { 2, 3 }
local function isPrime(n)
   if n == 1 then return true end
   for _,i in ipairs(prime_numbers) do
	  if n == i then return true end
	  if n%i == 0 then return false end
   end
   for i = prime_numbers[#prime_numbers], math.floor(n/2)+1, 2 do
	  if n%i == 0 then return false end
   end
   if n > prime_numbers[#prime_numbers] then
	  table.insert(prime_numbers, n)
   end
   return true
end
bench.math = function(a, b, c)

   local _a = a or 50000
   local _b = b or _a+50000
   local _c = c or 1
   act("Benchmark: math based prime number, args: ".._a.." ".._b.." ".._c)
   local res = { }
   for n=_a,_b,_c do 
	  if isHappy(n) and isPrime(n) then
		 table.insert(res, n)
	  end
   end
   return res
end

function bench.bit32(N)
   N = N or 1000
   act("Benchmark: bit32 based Mandelbrot generation, iterations: "..N)
   local bit = bit32
   local bor, band = bit.bor, bit.band
   local shl, shr, rol = bit.lshift, bit.rshift, bit.lrotate
   local char, unpack = string.char, table.unpack

   local M, buf = 2/N, {}
   for y=0,N-1 do
	  local Ci, b, p = y*M-1, -16777216, 0
	  local Ciq = Ci*Ci
	  for x=0,N-1,2 do
		 local Cr, Cr2 = x*M-1.5, (x+1)*M-1.5
		 local Zr, Zi, Zrq, Ziq = Cr, Ci, Cr*Cr, Ciq
		 local Zr2, Zi2, Zrq2, Ziq2 = Cr2, Ci, Cr2*Cr2, Ciq
		 b = rol(b, 2)
		 for i=1,49 do
			Zi = Zr*Zi*2 + Ci; Zi2 = Zr2*Zi2*2 + Ci
			Zr = Zrq-Ziq + Cr; Zr2 = Zrq2-Ziq2 + Cr2
			Ziq = Zi*Zi; Ziq2 = Zi2*Zi2
			Zrq = Zr*Zr; Zrq2 = Zr2*Zr2
			if band(b, 2) ~= 0 and Zrq+Ziq > 4.0 then b = band(b, -3) end
			if band(b, 1) ~= 0 and Zrq2+Ziq2 > 4.0 then b = band(b, -2) end
			if band(b, 3) == 0 then break end
		 end
		 if b >= 0 then p = p + 1; buf[p] = b; b = -16777216; end
	  end
	  if b ~= -16777216 then
		 if band(N, 1) ~= 0 then b = shr(b, 1) end
		 p = p + 1; buf[p] = shl(b, 8-band(N, 7))
	  end
	  -- write(char(unpack(buf, 1, p)))
	  -- write('.')
   end
   -- print('.')
end



return bench
local big = require'big'

return big
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local _cbor = require('cbor')

_cbor.decode = _cbor.raw_decode

_cbor.encode = function(tab)
   return _cbor.raw_encode(
	  -- encodes zencode types
	  I.process(tab)
   )
end

_cbor.auto = function(obj)
   local t = type(obj)
   if t == 'table' then
	  -- export table to JSON
	  return _cbor.encode(obj)
   elseif t == 'string' then
	  -- import JSON string to table
	  return _cbor.decode(obj)
   else
	  error("CBOR.auto unrecognised input type: "..t, 3)
	  return nil
   end
end

return _cbor
-- override type to recognize zenroom's types
luatype = type
_G['type'] = function(var)
   local simple = luatype(var)
   if simple == "userdata" then
	  local meta = getmetatable(var)
	  if meta then return(meta.__name)
	  else return("unknown") end
   else return(simple) end
end
-- TODO: optimise in C
function iszen(n)
   for c in n:gmatch("zenroom") do
	  return true
   end
   return false
end

-- gets a string and returns the associated function, string and prefix
function input_encoding(what)
   if what == 'u64' or what == 'url64' then
	  return { fun = function(data)
				  if O.is_url64(data) then return O.from_url64(data)
				  else error("Failed import from url64: "..what,3)
					 end end,
			   name = 'url64',
			   check = O.is_url64,
			   pfx = 'u64' }
   elseif what == 'b64' or what =='base64' then
	  return { fun = function(data)
				  if O.is_base64(data) then return O.from_base64(data)
				  else error("Failed import from base64: "..what,3)
					 end end,
			   name = 'base64',
			   check = O.is_base64,
			   pfx = 'b64' }
   elseif what == 'hex' then
	  return { fun = function(data)
				  if O.is_hex(data) then return O.from_hex(data)
				  else error("Failed import from hex: "..what,3)
				  end end,
			   name = 'hex',
			   check = O.is_hex,
			   pfx = 'hex' }
   elseif what == 'bin' or what == 'binary' then
	  return { fun = function(data)
				  if O.is_bin(data) then return O.from_bin(data)
				  else error("Failed import from bin: "..what,3)
					 end end,
			   name = 'binary',
			   check = O.is_bin,
			   pfx = 'bin' }
   elseif what == 'str' or what == 'string' then
   	  return { fun = O.from_string,
			   check = function(_) return true end,
   			   name = 'string',
   			   pfx = 'str' }
   elseif what == 'num' or what == 'number' then
	  return { fun = tonumber,
			   check = function(_) return true end,
			   -- check = function(a) if tonumber(a) ~= nil then
			   -- 		 return true else return false end,
			   name = 'number',
			   pfx = 'num' }
   else
	  warn("Conversion encoding not supported: "..what)
   end
   return nil
end

-- gets a string and returns the associated function, string and prefix
function get_encoding(what)
   if what == 'u64' or what == 'url64' then
	  return { fun = url64,
			   name = 'url64',
			   pfx = 'u64' }
   elseif what == 'b64' or what =='base64' then
	  return { fun = base64,
			   name = 'base64',
			   pfx = 'b64' }
   elseif what == 'hex' then
	  return { fun = hex,
			   name = 'hex',
			   pfx = 'hex' }
   elseif what == 'bin' or what == 'binary' then
	  return { fun = bin,
			   name = 'binary',
			   pfx = 'bin' }
   elseif what == 'str' or what == 'string' then
	  return { fun = str,
			   name = 'string',
			   pfx = 'str' }
   else
	  warn("Conversion encoding not supported: "..what)
   end
   return nil
end


function get_format(what)
   if what == 'json' or what == 'JSON' then
	  return { fun = JSON.auto,
			   name = 'json' }
   elseif what == 'cbor' or what == 'CBOR' then
	  return { fun = CBOR.auto,
			   name = 'cbor' }
   else
	  warn("Conversion format not supported: "..what)
   end
   return nil
end
	  
-- debugging facility
function xxx(s, n)
   n = n or 3
   if DEBUG >= n then
	  print("LUA "..s)
   end
end

function content(var)
   if type(var) == "zenroom.octet" then
	  INSPECT.print(var:array())
   else
	  INSPECT.print(var)
   end
end


-- sorted iterator for deterministic ordering of tables
-- from: https://www.lua.org/pil/19.3.html
_G["lua_pairs"]  = _G["pairs"]
_G["lua_ipairs"] = _G["ipairs"]
function _pairs(t)
   local a = {}
   for n in lua_pairs(t) do table.insert(a, n) end
   table.sort(a)
   local i = 0      -- iterator variable
   return function ()   -- iterator function
	  i = i + 1
	  -- if a[i] == nil then return nil
	  return a[i], t[a[i]]
   end
end
function _ipairs(t)
   local a = {}
   for n in lua_ipairs(t) do table.insert(a, n) end
   table.sort(a)
   local i = 0      -- iterator variable
   return function ()   -- iterator function
	  i = i + 1
	  -- if a[i] == nil then return nil
	  return a[i]
   end
end
-- Switch to deterministic (sorted) table iterators: this breaks lua
-- tests in particular those stressing i/pairs and pack/unpack, which
-- are anyway unnecessary corner cases in zenroom, which exits cleanly
-- and signaling a stack overflow. Please report back if this
-- generates problems leading to the pairs for loop in function above.
_G["sort_pairs"]  = _pairs
_G["sort_ipairs"] = _pairs

------------------------------
-- FUNCTIONAL LANGUAGE HELPERS
----------------------------------------
-- stateless map mostly for internal use
function _map(t, f, ...)
   -- safety
   if not (type(t) == "table") then return {} end
   if t == nil then return {} end
   -- if #t == 0  then return {} end

   local _t = {}
   for index,value in sort_pairs(t) do
	  local k, kv, v = index, f(index,value,...)
	  _t[v and kv or k] = v or kv
   end
   return _t
end
-- map values in place, sort tables by keys for deterministic order
function map(data, fun)
   if(type(data) ~= "table") then
	  error "map() first argument is not a table"
	  return nil end
   if(type(fun) ~= "function") then
	  error "map() second argument is not a function"
	  return nil end
   out = {}
   _map(data,function(k,v) out[k] = fun(v) end)
   return(out)
end

function isarray(obj)
   if not obj then error("isarray() called on a nil object",2) end
   if luatype(obj) ~= 'table' then error("isarray() argument is not a table",2) end
   local count = 0
   for k, v in pairs(obj) do
	  -- check that all keys are numbers
	  -- don't check sparse ratio (cjson's lua_array_length)
	  if luatype(k) ~= "number" then return 0 end
	  count = count + 1
   end
   return count
end

function help(module)
   if module == nil then
	  print("usage: help(module)")
	  print("example > help(octet)")
	  print("example > help(ecdh)")
	  print("example > help(ecp)")
	  return
   end
   for k,v in pairs(module) do
	  if type(v)~='table' and string.sub(k,1,1)~='_' then
		 print("class method: "..k)
	  end
   end
   -- local inst = module.new()
   -- if inst == nil then return end
   -- for s,f in pairs(getmetatable(inst)) do
   -- 	  if(string.sub(s,1,2)~='__') then print("object method: "..s) end
   -- end
end

-- TODO: optimize in C using strtok
local function split(src,pat)
   local tbl = {}
   src:gsub(pat, function(x) tbl[#tbl+1]=x end)
   return tbl
end
function strtok(src, pat)
   if not src then return { } end
   pat = pat or "%S+"
   ZEN.assert(luatype(src) == "string", "strtok error: argument is not a string")
   return split(src, pat)
end

-- assert all values in table are converted to zenroom types
-- used in zencode when transitioning out of given memory
function zenguard(tbl)
   for k,v in next,tbl,nil do
	  local ok = false
	  if luatype(v) == 'table' then
		 zenguard(v)
	  else
		 ok = iszen(type(v)) or tonumber(v)
		 ZEN.assert(ok,"Variable "..k.." has unconverted value type: "..type(v))
	  end
   end
end
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local ecdh = require'ecdh'

return ecdh
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local ecp = require'ecp'

function ecp.hashtopoint(s)
   return ecp.mapit(sha512(s))
end

function ecp.random()
   return ecp.mapit(OCTET.random(64))
end

return ecp
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local ecp2 = require'ecp2'
require'fp12' -- FP12 implicit

function ecp2.hashtopoint(s)
   return ecp2.mapit(sha512(s))
end

function ecp2.random()
   return ecp2.mapit(OCTET.random(64))
end

return ecp2
local fp = require'fp'

return fp
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local hash = require'hash'

-- when using facility functions, global hashers are created only once
SHA256 = nil
SHA512 = nil
local function init(bits)
   local h
   if bits == 256 or bits == 32 then
	  if SHA256==nil then SHA256 = hash.new('sha256') end
	  h = SHA256
   elseif bits == 512 or bits == 64 then
	  if SHA512==nil then SHA512 = hash.new('sha512') end
	  h = SHA512
   else
	  error("HASH bits not supported: "..bits)
   end
   return h
end

function sha256(data) return init(256):process(data) end
function sha512(data) return init(512):process(data) end
function KDF(data, bits)
   local b = bits or 256
   return init(b):kdf2(data)
end

return hash
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local J = require('json')


J.decode = function(data)
   if not data then error("JSON.decode error decoding nil string", 2) end
   -- assert(str ~= "","JSON.decode error decoding empty string")
   -- assert(type(str) == "string", "JSON.decode error unsopported type: "..type(str))
   local res = JSON.raw_decode( str(data) )
   if not res then error("JSON.decode error decoding type: "..t, 2) end
   return res
end

J.encode = function(tab)
   return
	  JSON.raw_encode(
		 -- process encodes zencode types
		 -- it is part of inspect.lua
		 INSPECT.process(tab)
	  )
   -- return JSON.raw_encode(tab)
end

J.auto = function(obj)
   local t = type(obj)
   if t == 'table' then
	  -- export table to JSON
	  return JSON.encode(obj)
   elseif t == 'string' then
	  -- import JSON string to table
	  return JSON.decode(obj)
   else
	  error("JSON.auto unrecognised input type: "..t, 3)
	  return nil
   end
end

return J
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local octet = require'octet'

--- implicit convertion functions going both ways
-- if input is an encoded string, will become an octet
-- if input is a non-encoded string, it will become a base64 string
-- if input is an octet, will become an encoded string
function hex(data)
   local t = type(data)
   if(t == "string") then
	  if O.is_hex(data) then return O.from_hex(data)
	  else return O.from_str(data):hex() end
   elseif(t == "number") then return data
   elseif(t == "table") then return data
   elseif(t == "zenroom.octet") then return data:hex()
   elseif iszen(t) then return data:octet():hex() -- any zenroom type to octet
   end
end
function str(data)
   local t = type(data)
   if(t == "string") and data ~= "" then
	  if OCTET.is_url64(data) then
		 -- return decoded string format for JSON.decode
		 return OCTET.from_url64(data):str()
	  elseif OCTET.is_base64(data) then
		 -- return decoded string format for JSON.decode
		 return OCTET.from_base64(data):str()
	  elseif OCTET.is_hex(data) then
		 -- return decoded string format for JSON.decode
		 return OCTET.from_hex(data):str()
	  elseif OCTET.is_bin(data) then
		 -- return decoded string format for JSON.decode
		 return OCTET.from_bin(data):str()
	  else -- its already a string (we suppose, this is not deterministic)
		 return data
	  end
   elseif t == 'zenroom.octet' then
	  return data:str()
   elseif iszen(t) then
	  return data:octet():str()
   else
	  error("automatic str() conversion failed for type: "..t)
   end
end

function bin(data)
   local t = type(data)
   if(t == "string") then
	  if O.is_bin(data) then return O.from_bin(data)
	  else return O.from_str(data):bin() end
   elseif(t == "number") then return data
   elseif(t == "table") then return data
   elseif(t == "zenroom.octet") then return data:bin()
   elseif iszen(t) then return data:octet():bin() -- any zenroom type to octet
   end
end
function base64(data)
   if not data then error("Internal data conversion on nil",2) end
   local t = type(data)
   if(t == "string") then
	  if O.is_base64(data) then return O.from_base64(data)
	  else return O.from_str(data):base64() end
   elseif(t == "number") then return data
   elseif(t == "table") then return data
   elseif(t == "zenroom.octet") then return data:base64()
   elseif iszen(t) then return data:octet():base64() -- any zenroom type to octet
   end
end
function url64(data)
   if not data then error("Internal data conversion on nil",2) end
   local t = type(data)
   if(t == "string") then
	  if O.is_url64(data) then return O.from_url64(data)
	  else return O.from_str(data):url64() end
   elseif(t == "number") then return data
   elseif(t == "table") then return data
   elseif(t == "zenroom.octet") then return data:url64()
   elseif iszen(t) then return data:octet():url64() -- any zenroom type to octet
   end
end
function base58(data)
   local t = type(data)
   if(t == "string") then
	  if O.is_base58(data) then return O.from_base58(data)
	  else return O.from_str(data):base58() end
   elseif(t == "zenroom.octet") then return data:base58()
   elseif iszen(t) then return data:octet():base58() -- any zenroom type to octet
   end
end

-- serialize an array containing any type of cryptographic numbers
octet.serialize = function(arr)
   total = 0
   map(arr, function(a) 
		  t = type(a)
		  -- supported lua native types
		  if(t == "string") then total = total + #a return
		  elseif(t == "number") then total = total + #tostring(a) return
		  elseif not iszen(t) then
			 error("OCTET.serialize: unsupported type: "..t)
		  end
		  if(t == "zenroom.octet") then
			 total = total + #a
		  elseif(t == "zenroom.big"
					or
					t == "zenroom.ecp"
					or
				 t == "zenroom.ecp2") then
			 total = total + #a:octet()
		  else
			 error("OCTET.serialize: unsupported zenroom type: "..t)
		  end
   end)
   concat = O.new(total)
   map(arr,function(e)
		  t = type(e)
		  -- supported lua native types
		  if(t == "string") then concat = concat .. O.from_str(e) return
		  elseif(t == "number") then concat = concat .. O.from_str(tostring(e)) return
		  elseif not iszen(t) then
			 error("OCTET.serialize: unsupported type: "..t)
		  end
		  if(t == "zenroom.octet") then
			 concat = concat .. e
		  elseif(t == "zenroom.big"
				 or
				 t == "zenroom.ecp"
				 or
				 t == "zenroom.ecp2") then
			 concat = concat .. e:octet()
		  else
			 error("OCTET.serialize: unsupported zenroom type: "..t)
		  end
   end)
   return concat
end

function zero(len)    return octet.new(len):zero(len) end

return octet
-- This file is part of Zenroom (https://zenroom.dyne.org)
--
-- Copyright (C) 2018-2019 Dyne.org foundation
-- designed, written and maintained by Denis Roio <jaromil@dyne.org>
--
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Affero General Public License as
-- published by the Free Software Foundation, either version 3 of the
-- License, or (at your option) any later version.
--
-- This program is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU Affero General Public License for more details.
--
-- You should have received a copy of the GNU Affero General Public License
-- along with this program.  If not, see <https://www.gnu.org/licenses/>.

local rng = require'rng'

-- global facility function
function random(len) return RNG.new():octet(len) end

return rng
